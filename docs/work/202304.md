# 202304

金三银四，四月你还好吗!是否虚度了阳春三月，没关系，往前看，人间四月等着你去努力

:::tip

人间四月芳菲尽，山寺桃花始盛开

:::

## 0401

- 注册了一个 Chatgpt 账户，验证手机号码花了几块钱租了一个[拉脱维亚的虚拟号进行验证](https://sms-activate.org/cashBack),随便搞个 OpenApi Key: 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, [OpenApi 后台](https://platform.openai.com/)

-接下来每天积累五条面试相关经验

在前端面试中，可能会问到以下 React 相关的面试题：

介绍 React 生命周期。

React 中的组件通信方式有哪些？

什么是虚拟 DOM？如何实现虚拟 DOM？

React 中的状态管理方式有哪些？

如何优化 React 的性能？

React 中的 key 属性有什么作用？

什么是高阶组件？如何创建高阶组件？

React 中的 ref 属性有什么作用？(from gpt)

在 React 中，ref 是用于获取组件或 DOM 元素引用的属性。通过 ref，我们可以在 React 组件渲染完成之后，访问组件或 DOM 元素的属性和方法，从而实现一些 DOM 操作或组件交互。
回调函数 ref 不仅可以用来获取 DOM 元素的引用，还可以用来获取组件的**实例引用**。当使用回调函数 ref 来获取组件实例时，该回调函数的参数就是组件的实例引用。例如：

```js
import React, { Component } from "react";

class MyComponent extends Component {
  doSomething() {
    // do something
    console.log("child comp");
  }

  render() {
    return (
      <div>
        <button
          onClick={() => {
            this.props.onClick(this);
          }}
        >
          Click me
        </button>
      </div>
    );
  }
}

class App extends Component {
  handleClick = (component) => {
    component.doSomething();
  };

  render() {
    return (
      <div>
        <MyComponent onClick={this.handleClick} />
      </div>
    );
  }
}
```

React Hooks 是什么？有哪些常用的 Hooks？

什么是 Context？如何使用 Context？

介绍 React 中的路由。

React 中的事件处理方式有哪些？

如何使用 Redux 进行状态管理？

React 和 Vue 的区别有哪些？

- JIT 编译器：在 Tailwind CSS v2.1.0 及以后的版本中，Tailwind CSS 引入了一个 JIT（Just-In-Time）编译器，它的作用是**动态地生成 CSS 样式类**，这样可以大大减少 CSS 文件的大小。在运行时，JIT 编译器会根据用户的实际使用情况动态生成 CSS 样式类，并将其添加到最终的 CSS 文件中。

- [前端框架的 JIT 和 AOT 编译方案](https://mp.weixin.qq.com/s/J-13uueQVe-OBinXr669EQ)

现代前端框架都需要“编译”这一步骤，用于：

1.将框架中描述的 UI 转换为宿主环境可识别的代码

2.代码转化，比如将 ts 编译为 js、实现 polyfill 等

3.执行一些编译时优化

4.代码打包、压缩、混淆

编译可以选择放在两个时机执行：

代码构建时，被称为 **AOT（Ahead Of Time，提前编译或预编译）**，宿主环境获得的是编译后的代码

代码在宿主环境执行时，被称为 **JIT（Just In Time，即时编译）**，代码在宿主环境编译并执行

### 如何通过编译器的优化原理，如何提高 JavaScript 的执行效率？(from gpt)

编译器的优化原理主要是基于静态分析和运行时优化两个方面来实现的，可以通过以下方式来提高 JavaScript 的执行效率：

- 减少变量的使用：在 JavaScript 中，变量的使用会导致内存分配和垃圾回收等操作，从而影响代码的执行效率。因此，在编写 JavaScript 代码时，应尽量减少变量的使用。

- 避免频繁创建对象和数组：在 JavaScript 中，创建对象和数组会导致内存分配和垃圾回收等操作，从而影响代码的执行效率。因此，在编写 JavaScript 代码时，应尽量避免频繁创建对象和数组。

- 使用函数节流和函数防抖：在处理一些频繁触发的事件时，可以使用函数节流和函数防抖来优化代码的执行效率。函数节流可以控制函数的执行频率，从而避免频繁的操作，而函数防抖可以在一定的延迟时间之后执行函数，从而避免重复执行。

- 使用 Web Worker：Web Worker 可以在独立的线程中执行 JavaScript 代码，从而避免阻塞主线程，提高代码的执行效率。

- 使用编译器的优化原理：编译器的优化原理可以帮助我们优化 JavaScript 代码的执行效率，例如使用 webpack、rollup 等构建工具来进行代码压缩和打包，使用 Babel 等工具进行语法转换和优化等操作，从而减少 JavaScript 代码的体积和提高代码的执行效率。

- 使用代码优化工具：使用一些代码优化工具，例如 Google 的 Closure Compiler、UglifyJS 等，可以帮助我们对 JavaScript 代码进行分析和优化，从而提高代码的执行效率。

总之，在提高 JavaScript 的执行效率时，需要结合编译器的优化原理、代码优化工具和代码编写习惯等多个方面进行综合优化。

### JavaScript 是如何执行的？(from gpt)

JavaScript 的执行过程可以分为两个阶段：编译阶段和执行阶段。

编译阶段：在编译阶段，JavaScript 引擎会对代码进行词法分析和语法分析，生成抽象语法树（AST），并且对代码进行预编译，例如变量提升、函数声明提升等操作。在这个阶段，JavaScript 引擎会检查代码是否符合语法规范，并生成执行上下文（Execution Context）。

执行阶段：在执行阶段，JavaScript 引擎会按照编译阶段生成的执行上下文执行代码。执行上下文包含了变量、函数、作用域链等信息，JavaScript 引擎根据作用域链来查找变量和函数，并且在执行过程中进行变量赋值、函数调用等操作。在执行过程中，JavaScript 引擎会将代码分为同步任务和异步任务，同步任务会按照顺序执行，而异步任务会先被放到任务队列中，等待下一个事件循环执行。

JavaScript 引擎执行代码时，还会进行垃圾回收和优化等操作。垃圾回收是指当变量或对象不再被引用时，会被自动清除内存空间，从而避免内存泄漏。优化是指 JavaScript 引擎会根据代码的执行情况进行优化，例如 JIT 编译、预解析等操作，从而提高代码的执行效率。

总之，JavaScript 的执行过程是一个编译和执行的过程，通过编译阶段和执行阶段的协同工作，JavaScript 能够完成对代码的解析和执行。

### 说下 TS 中的泛型(from gpt)

在 TypeScript 中，泛型允许我们在定义函数、类或接口时不预先指定类型，而是在使用时再动态指定类型，以增加代码的灵活性和复用性。(定义时不指定具体类型)

泛型的基本语法是使用尖括号`<T>`（T 可以替换为任意标识符），将类型参数声明在函数或类名之后

```ts
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function (x, y) {
  return x + y;
};
```

## 0402

- modern.js 中的 NoSSR

```ts
import { useEffect, useState } from "react";

export function NoSSR(props: { children: React.ReactNode }) {
  const { children } = props;
  const [isMounted, setIsMounted] = useState(false);

  useEffect(() => {
    setIsMounted(true);
  }, []);

  if (!isMounted) {
    return null;
  } else {
    return <div>{children}</div>;
  }
}
```

### 每日一题：面试官问，说下 react fiber 原理

React Fiber 是 React v16 中引入的新的协调引擎，它的目标是提高 React 的渲染性能和用户体验。

传统的 React 渲染方式是基于递归调用的，这种方式存在一些问题，比如在渲染大量组件时会造成主线程阻塞，影响用户体验。React Fiber 的出现解决了这个问题，它使用了一种新的调度算法，将渲染工作分解为多个阶段，每个阶段可以中断和恢复，从而实现了优先级控制和异步渲染，提高了 React 的渲染性能和用户体验。

React Fiber 的实现原理如下：

- 构建 Fiber 树：在渲染过程中，React 会创建一颗 Fiber 树，表示所有需要更新的组件以及它们的关系。与传统的虚拟 DOM 不同的是，Fiber 树不仅包含组件的结构，还包含组件的状态、生命周期等信息。

- 调度更新：当组件状态发生变化时，React 会根据优先级调度更新，将更新任务分解成多个阶段，每个阶段对应一个优先级。React 会根据优先级和剩余时间来决定当前阶段能否执行，从而实现优先级控制和异步渲染。

- 执行更新：当当前阶段可以执行时，React 会遍历 Fiber 树，执行对应阶段的更新任务。React Fiber 引入了一种新的数据结构叫做 FiberNode，用来描述每个需要更新的组件，包含组件的类型、props、state 等信息。遍历 Fiber 树时，React Fiber 会根据 FiberNode 之间的关系执行更新任务，并将更新结果保存在 FiberNode 中。

- 提交更新：当所有阶段的更新任务都执行完毕时，React Fiber 会将更新结果一次性提交到浏览器中，实现视图的更新。React Fiber 还引入了另一种新的数据结构叫做 SideEffect，用来保存更新过程中产生的副作用，比如需要插入、删除或更新 DOM 元素。在提交更新时，React Fiber 会根据 SideEffect 进行批量操作，减少浏览器的重绘和回流，提高性能。

总之，React Fiber 的实现原理主要是基于优先级调度、阶段分解、中断恢复和批量更新等技术，通过这些技术实现了高效的异步渲染和优先级控制。

## 0403

- [width:fit-content 使用场景](https://codesandbox.io/s/elegant-violet-4q3mig?file=/src/styles.css:106-117)
  ![fit-content](https://www.bythewayer.com/img/max-content.webp)
  width: fit-content(fit-content min(max-content, max(min-content, length-percentage)))，它可以**根据元素的内容自动计算宽度，实现自适应宽度的效果**。与 width: auto 相比，width: fit-content 可以使元素的宽度不会超出其包含块的宽度，而 width: auto 则可能会导致元素宽度超出包含块的宽度。

width: max-content 用于指定元素的宽度为其包含内容的最大宽度。

具体来说，当应用该属性时，元素的宽度将会自动调整为其内部内容的最大宽度。例如，如果一个元素包含了一个很长的文本行，那么该元素的宽度将会自动调整为文本行的最大宽度。

这个属性在实现自适应布局、表格自适应等方面非常有用。在实现自适应布局时，我们经常需要根据内容的大小来动态地调整元素的宽度，而 max-content 正是为这种场景而生的。

width: min-content 指元素宽度自动调整为其所包含的最小内容。如果元素的内容比它的宽度更窄，那么该元素将以内容的宽度为基础来进行渲染。如果该元素的内容比其宽度更宽，则会按照其默认的宽度来渲染，并在容器中溢出

- cors 中个的 withCredentials 有什么用(from gpt)

  withCredentials 是 XMLHttpRequest 对象的一个属性，它是用于指定跨域请求时是否携带 Cookie 和认证信息的。当设置 withCredentials 为 true 时，请求中会携带当前域的 Cookie 和认证信息，而这些信息会被浏览器自动添加到请求的头部中。如果没有设置 withCredentials，则请求头中不会包含 Cookie 和认证信息。需要注意的是，当开启 withCredentials 属性后，服务器端需要配置响应头 Access-Control-Allow-Credentials 为 true，才能使得请求能够成功返回数据。

### 每日一题，说下 react 和 vue 区别(from gpt)

Vue 和 React 是目前最流行的前端框架之一，虽然两者都可以用来构建单页面应用程序 (SPA)，但在实现细节和编程模型上有一些不同点。以下是一些主要的区别：

模板语法不同：Vue 使用基于 HTML 的模板语法，而 React 使用 JavaScript 中的 JSX 语法。

组件定义方式不同：Vue 中定义组件时使用的是对象字面量的方式，而 React 中使用 ES6 类或函数式组件的方式。

数据绑定方式不同：Vue 使用双向数据绑定 (two-way data binding)，而 React 使用单向数据流 (one-way data flow)。

组件通信方式不同：Vue 使用 prop 和自定义事件进行父子组件之间的通信，而 React 使用 props 和回调函数。

状态管理方式不同：Vue 使用 Vuex 进行状态管理，而 React 使用 Redux 或者 Context API 进行状态管理。

渲染方式不同：Vue 使用模板编译的方式进行渲染，而 React 使用虚拟 DOM 进行渲染。

性能优化方面不同：Vue 通过模板编译的方式进行编译优化，而 React 通过使用 Fiber 架构和异步渲染等方式进行性能优化。

总的来说，Vue 更加注重开发者友好和快速开发，而 React 更加注重灵活性和可维护性。选择使用哪个框架，应该根据具体项目需求和开发团队的技术背景来决定。

### 每日一题，说下 react 中的并发更新

### react 表单受控组件和非受控组件优缺点

## 0404

- CSS 属性 **overflow-wrap** 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。

```css
overflow-wrap: break-word; // 英文字母不换行处理
```

- [算法题，合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/description/)

> 太失败了 逻辑思维太差劲

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
  nums1.splice(m, n, ...nums2);
  nums1.sort((a, b) => a - b);
};
```

- splice 实现数组增加元素

```js
const arr = [1, 2, 3, 4, 5, 6];
arr.splice(3, 0, 7, 7); // 从索引为3的位置删除0个元素添加7 和 7
console.log(arr); // [1，2，3，7，7， 4，5，6]

// 从索引 2 的位置开始删除所有元素
var myFish = ["angel", "clown", "mandarin", "sturgeon"];
var removed = myFish.splice(2);
// 运算后的 myFish: ["angel", "clown"]
// 被删除的元素：["mandarin", "sturgeon"]

// 从索引 -2 的位置开始删除 1 个元素
var myFish = ["angel", "clown", "mandarin", "sturgeon"];
var removed = myFish.splice(-2, 1);
// 运算后的 myFish: ["angel", "clown", "sturgeon"]
// 被删除的元素：["mandarin"]

// 从索引 2 的位置开始删除 1 个元素，插入“trumpet”
var myFish = ["angel", "clown", "drum", "sturgeon"];
var removed = myFish.splice(2, 1, "trumpet");
// 运算后的 myFish: ["angel", "clown", "trumpet", "sturgeon"]
// 被删除的元素：["drum"]
```

## 0405 清明节放假一天

- Headless CMS?
  > 就是没有展示界面，只提供内容管理和内容 API 的 CMS

Headless CMS（Headless Content Management System）是一种新型的内容管理系统。相对于传统的 CMS，Headless CMS 更加注重内容管理系统的内容管理能力，而不是提供页面模板等展示功能。Headless CMS 通过提供 API 来将内容与展示分离，使得前端展示可以更加灵活和多样化。

Headless CMS 的工作方式如下：

内容管理：Headless CMS 提供一套完善的内容管理工具，可以帮助管理员更加便捷地创建、修改、发布和管理各种内容。

API 调用：Headless CMS 将内容以 API 的形式暴露出来，前端可以通过 API 调用来获取数据，从而自由地进行展示和定制。

前端展示：由于 Headless CMS 与展示无关，因此前端可以使用各种技术和工具来实现展示，例如 React、Vue、Angular 等等。

Headless CMS 可以在各种场景下使用，例如单页应用、移动应用、静态网站等。它的优点包括更加灵活的前端展示、更加易于扩展和定制、更加适合多平台展示等等。

- [tailwindcss](https://tailblocks.cc/), 首先推荐一个网站 tailblocks.cc， 它拥有 50+ 代码块，在右上角可以切换网站主题颜色，所有的代码块都是响应式的，并且支持暗黑皮肤。 通过键盘左右键可以快速切换、预览效果。

- 从 0 到 1 搭建个人博客，需要使用的技术有 nextjs+tailwindcss,从此刻开始实践,需要用到的包有

```js
import Markdown from "markdown-it";
import matter from "gray-matter";
```
