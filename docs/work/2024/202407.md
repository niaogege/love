# 202407

::: info

> 20240603

> 刚来部门，需要熟悉业务情况，也不知道需要熟悉啥

> 睡眠还是没有解决，老是被狗喊醒,希望 7 月份的时候能缓解

:::

## 0704

- 1121，三年 1 个月
- 周二昨晚 NT,一切正常，希望大人和小孩一路绿灯
- 前段时间太忙了，根本没有时间去记录，最近稍微好一点
- 家里亲戚俩个弟弟，一个考了 642，一个 459，性格差异太大，希望自己的小孩身心健康正常就行，能考多少是多少，不强求

## 0706

- 1123
- 送老妈回南京，下次老妈来上海还不知道啥时候，也许是生产的时候，也许就不会再来上海了

## 0708

- 1125，140(目标 2024/12)
- 本周要做的几件事：会员和换肤页面
- 闲暇时光，翻一番面试清单和记录吧，怀孕确实让自己这俩月乱了节奏，但终归还是要回归平静

## 0719

- 页面级加载 loading 效果
- 查看[micro-event-manager 源码](https://github.com/xinkule/micro-event-manager#readme)

```ts
type Fn = (data?: any) => void

interface Event {
  key: number
  callback: Fn
}

interface PublishedEvents {
  name: string
  data?: any
}

export class EventManager {
  _events: { [key: string]: Event[] } = {}

  _publishedEvents: PublishedEvents[] = []

  _uniqueId = 0 // use self increasing number to guarantee global uniqueness

  subscribe(name: string, callback: Fn): number {
    if (!this._events[name]) {
      this._events[name] = []
    }
    const event = { key: this._uniqueId++, callback }
    this._events[name].push(event)
    return event.key
  }

  publish(name: string, data?: any): void {
    this._publishedEvents.push({ name, data })
    if (this._events[name]) {
      this._events[name].forEach(({ callback }): void => {
        callback(data)
      })
    }
  }

  unSubscribe(name: string, key: number): void {
    if (this._events[name]) {
      for (let i = 0; i < this._events[name].length; i++) {
        if (key === this._events[name][i].key) {
          this._events[name].splice(i, 1)
          break
        }
      }
    }
  }

  // Make sure published events can be triggered when subscribed
  ensureTriggeredAndSubscribe(name: string, callback: Fn): number {
    const event = this._publishedEvents
      .slice()
      .reverse()
      .find((item) => item.name === name)
    if (event) {
      callback(event.data)
    }
    return this.subscribe(name, callback)
  }
}
```

使用

```ts
import { EventManager } from "micro-event-manager"

// first create a manager instance
const eventManager = new EventManager()

// then subscribe to an event, it will return an unique key
const key = eventManager.subscribe("log", () => {
  console.log("executed")
})

// trigger the event, the second argument is optional
eventManager.publish("log", "data")

// you can use the generated key to unsubscribe the event
eventManager.unSubscribe("log", key)

// when you are not sure if the subscription happens before the publishment
// and you want to make sure any published events should be triggered, you can use this function to subscribe
eventManager.ensureTriggeredAndSubscribe("log", () => {
  console.log("executed")
})
```

## 0720

- 1137,128
- 换肤有个锚点效果搞了好久，最主要的原因是滚动，滚动到某一区域的时候老是在抖动？原因是锚点区域距离顶部的位移变化了导致抖动，如何拒绝这种情况呢？
- 忙于业务迭代，基本没时间搞其他研发，其实这不是自己想要的结果，还是希望自己能沉淀下来，拿出点不一样的结果
