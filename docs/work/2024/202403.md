# 202403

::: info

> 能熬到现在 说明运气不错，如果没有熬到，那就只需要努力即可
> 20240105

> 算法题犹如一座横亘在我面前的一座大山，什么时候才能翻过去？翻过去就能海阔天空？

:::

## 0301

- 996 天, 95
- 偏函数的定义和应用场景？
- react18 自动批处理？
- 在 v18 之前，只有事件回调、生命周期回调中的更新会批处理，比如上例中的 onClick。而在 promise、setTimeout 等异步回调中不会批处理。

```js
state = {
  a: 0
}
onClick() {
  this.setState({a: 1});
  console.log('a is:', this.state.a);
  this.setState({a: 2});
}
render() {
  const {a} = this.state;
  return <p onClick={this.onClick}>{a}</p>;
}
```

- 在 React 并发模式中，引入了两个主要概念：任务调度和优先级。任务调度器负责决定哪些任务执行、何时执行以及中断和恢复任务。优先级允许 React 根据任务的紧迫性来安排任务的执行顺序，确保响应度更高的任务能够优先执行。
  利用并发模式，React 可以将渲染过程分解为多个小任务，并根据优先级来动态调整任务执行的顺序。这样，在浏览器空闲时间或网络请求等异步操作期间，React 可以暂停当前任务，执行其他具有更高优先级的任务，以实现更爽快的用户交互体验。
  总而言之，React 并发模式通过任务调度和优先级机制，提供了更好的用户体验和性能，使得 React 应用程序能够更加平滑地响应用户操作。

## 0302

- 997,94
- 面试次数还是太少，没有积累足够多的经验，没有什么信心不信心，干就是了
- 每一次面对算法题都是历史与现在的交汇，历史我忘记得太快了，这就是时间的惩罚，解决办法就是不停重发默写，默写，直到记到骨子里，然后融入到脑子里

## 0303

- 998,93
- 每次面试准备，都无从下手，如何化繁为简？只要回忆 60%核心内容，加强核心内容背诵
- [2023 行情不好，大龄员工如何跳槽](https://juejin.cn/post/7300118821533089807)

## 0304

- 999，92,这数字不错，吉祥如意
- 如果能成功进入到下一家，半年之内我会跟面试说拜拜，但是算法题永远不会说拜拜，天天记这些枯燥的术语感觉没啥大用
- 这几天，多多背诵核心知识点，巩固记忆(网络和浏览器相关)，即使休息在家，天天看这些知识点，依然不能很好的记住，需要强化记忆，反复背诵
- 算法题核心算法，多练习几遍
- **navigator.sendBeacon** 优势：有机会异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一个导航的载入性能

## 0305

- 1000,91
- [前端系统复习](https://juejin.cn/column/6964717704712290317])
- [react17Vsreact18](https://juejin.cn/post/7157888552229928996#heading-12)
- 缺少架构经验？
  如何结合项目，怎么补充
- 了解使用 rollup/vite/webpack 等打包工具以及前端性能优化？
  这点如何结合项目经验，使得在面试的时候有话说？

- application/json: 表示请求体是 JSON 格式的数据。
  application/x-www-form-urlencoded: 表示请求体采用 URL 编码的表单数据。

## 0306

- 1001,90
- 果然什么时候，都不会准备好面试的？everyTime,接雨水我写了将近十遍还是遗忘，二叉树的最近公共祖先也是写了近十遍，[递归还是写不出来](https://www.bilibili.com/video/BV1UD4y1Y769/，要命了

```js
function publicAn(root, p, q) {
  if (root == null || p == root || q == root) return root;
  let left = publicAn(root.left, p, q);
  let right = publicAn(root.right, p, q);
  if (left != null && right != null) return root;
  if (left == null && right != null) return right;
  if (left == null && right != null) return left;
  return null;
}
```

- Tree shaking（树摇）是一种代码优化技术，它依赖于 ES6 模块（ES6 modules）的静态结构。Tree shaking 的工作原理是通过消除未使用的代码，从而减小最终的 bundle 大小。这个过程主要涉及到两个步骤：**静态分析**和**代码生成**。Tree shaking 的主要优点是它可以减小 bundle 的大小，从而提高加载速度和运行效率
- vite 打包工具涉及到的性能优化

### Navigator.sendBeacon

Navigator.sendBeacon 是一个现代的、轻量级的方法，它允许在不阻塞页面卸载的情况下发送数据。

```js
navigator.sendBeacon("/api/data", JSON.stringify(data));
```

- 通过 HTTP POST 请求方式 异步 发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能；
- 支持跨域，但不支持自定义 headers 请求头，这意味着：如果用户信息 Access-Token 是作为请求头信息传递，需要后台接口支持 url querystring 参数传递解析。需要考虑其兼容性。

## 0307

- 1002,89
