# 202403

::: info

> 能熬到现在 说明运气不错，如果没有熬到，那就只需要努力即可
> 20240105

> 算法题犹如一座横亘在我面前的一座大山，什么时候才能翻过去？翻过去就能海阔天空？

:::

## 0301

- 996 天, 95
- 偏函数的定义和应用场景？
- react18 自动批处理？
- 在 v18 之前，只有事件回调、生命周期回调中的更新会批处理，比如上例中的 onClick。而在 promise、setTimeout 等异步回调中不会批处理。

```js
state = {
  a: 0
}
onClick() {
  this.setState({a: 1});
  console.log('a is:', this.state.a);
  this.setState({a: 2});
}
render() {
  const {a} = this.state;
  return <p onClick={this.onClick}>{a}</p>;
}
```

- 在 React 并发模式中，引入了两个主要概念：任务调度和优先级。任务调度器负责决定哪些任务执行、何时执行以及中断和恢复任务。优先级允许 React 根据任务的紧迫性来安排任务的执行顺序，确保响应度更高的任务能够优先执行。
  利用并发模式，React 可以将渲染过程分解为多个小任务，并根据优先级来动态调整任务执行的顺序。这样，在浏览器空闲时间或网络请求等异步操作期间，React 可以暂停当前任务，执行其他具有更高优先级的任务，以实现更爽快的用户交互体验。
  总而言之，React 并发模式通过任务调度和优先级机制，提供了更好的用户体验和性能，使得 React 应用程序能够更加平滑地响应用户操作。

## 0302

- 997,94
- 面试次数还是太少，没有积累足够多的经验，没有什么信心不信心，干就是了
- 每一次面对算法题都是历史与现在的交汇，历史我忘记得太快了，这就是时间的惩罚，解决办法就是不停重发默写，默写，直到记到骨子里，然后融入到脑子里

## 0303

- 998,93
- 每次面试准备，都无从下手，如何化繁为简？只要回忆 60%核心内容，加强核心内容背诵
- [2023 行情不好，大龄员工如何跳槽](https://juejin.cn/post/7300118821533089807)

## 0304

- 999，92,这数字不错，吉祥如意
- 如果能成功进入到下一家，半年之内我会跟面试说拜拜，但是算法题永远不会说拜拜，天天记这些枯燥的术语感觉没啥大用
- 这几天，多多背诵核心知识点，巩固记忆(网络和浏览器相关)，即使休息在家，天天看这些知识点，依然不能很好的记住，需要强化记忆，反复背诵
- 算法题核心算法，多练习几遍
- **navigator.sendBeacon** 优势：有机会异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一个导航的载入性能

## 0305

- 1000,91
- [前端系统复习](https://juejin.cn/column/6964717704712290317])
- [react17Vsreact18](https://juejin.cn/post/7157888552229928996#heading-12)
- 缺少架构经验？
  如何结合项目，怎么补充
- 了解使用 rollup/vite/webpack 等打包工具以及前端性能优化？
  这点如何结合项目经验，使得在面试的时候有话说？

- application/json: 表示请求体是 JSON 格式的数据。
  application/x-www-form-urlencoded: 表示请求体采用 URL 编码的表单数据。

## 0306

- 1001,90
- 果然什么时候，都不会准备好面试的？everyTime,接雨水我写了将近十遍还是遗忘，二叉树的最近公共祖先也是写了近十遍，[递归还是写不出来](https://www.bilibili.com/video/BV1UD4y1Y769/，要命了

```js
function publicAn(root, p, q) {
  if (root == null || p == root || q == root) return root;
  let left = publicAn(root.left, p, q);
  let right = publicAn(root.right, p, q);
  if (left != null && right != null) return root;
  if (left == null && right != null) return right;
  if (left == null && right != null) return left;
  return null;
}
```

- Tree shaking（树摇）是一种代码优化技术，它依赖于 ES6 模块（ES6 modules）的静态结构。Tree shaking 的工作原理是通过消除未使用的代码，从而减小最终的 bundle 大小。这个过程主要涉及到两个步骤：**静态分析**和**代码生成**。Tree shaking 的主要优点是它可以减小 bundle 的大小，从而提高加载速度和运行效率
- vite 打包工具涉及到的性能优化

### Navigator.sendBeacon

Navigator.sendBeacon 是一个现代的、轻量级的方法，它允许在不阻塞页面卸载的情况下发送数据。

```js
navigator.sendBeacon("/api/data", JSON.stringify(data));
```

- 通过 HTTP POST 请求方式 异步 发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能；
- 支持跨域，但不支持自定义 headers 请求头，这意味着：如果用户信息 Access-Token 是作为请求头信息传递，需要后台接口支持 url querystring 参数传递解析。需要考虑其兼容性。

## 0307

- 1002,89

### 总结 SEO 相关的知识？

- 区分 seo 产品和用户产品
- 不想分摊权重的链接加上 nofollow：告诉搜索引擎不要收录这个链接的网页
- robots.txt：文件规定了搜索引擎抓取工具可以访问你网站上的哪些网址
- 404 页面做好引导

- [一句话解释 Webpack 的构建原理？](https://zhuanlan.zhihu.com/p/663644420)

::: details

前端之所有需要 类似于 Webpack 这样的构建工具，是为了提高项目的开发效率，Webpack 通过分析 js 中的 require 语句，分析出当前 js 文件所有的依赖文件，通过递归的方式层层分析后，得到整个项目的依赖关系图，对不同的文件执行不同的 loader，比如使用 css-loader 解析 css 代码，最后基于这个依赖关系图读取到整个项目中的所有文件代码，进行打包处理之后交给浏览器执行。

:::

### useCallback useMemo, 为什么会减少 render？

本质上，useMemo 和 useCallback 都是用来帮助我们优化 **重新渲染** 的工具 Hook。它们通过以下两种方式实现优化的效果。

- 减少在一次渲染中需要完成的工作量。
- 减少一个组件需要重新渲染的次数。

```js
const [count, setCount] = useState(0);
// one
const handler = React.memo(() => {
  return function () {
    setCount((val) => val++);
  };
}, []);
const handler = React.useCallback(() => {
  setCount((val) => val++);
}, []);
```

换句话说就是以下的两种实现方式的效果是相同的：

```js
React.useCallback(function helloWorld() {}, []);

// ...功能相当于:
React.useMemo(() => function helloWorld() {}, []);
```

## 0308

- 1002, 88
- 还有 2 天就面试了，从容心态面对，紧张没有用，面过这么多次，有啥好囧怕的。如果后面因为算法题没过，自己认命，如果不是因为算法题，那确实有点遗憾
- nextjs 中的 ssr 和 ssg 中的怎么说

::: details

- SSR: getServerSideProps?
- SSG: 静态渲染
- ISG: 增量静态渲染

:::
