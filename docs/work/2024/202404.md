# 202404

每一个人都有不一样的闪光点,所以要找到属于自己的那一片麦田,然后挥酒汗水,彻彻底底的完成自我实现?

> so,我的麦田在哪里？

::: info

> 春暖花开 万物复苏
> 20240222

> 横亘在前面的两座大山都解决的怎么样了

> 天天手写，总得有点思考吧，不能老是一成不变，死记硬背

:::

## 0401

- 1027 天,64
- 浏览 2 个 npm 仓库，[React DnD](https://react-dnd.github.io/react-dnd/about)和 [immutability-helper](https://www.npmjs.com/package/immutability-helper)
- 一天天的，也不知道自己想做什么，乱的很，想做小程序，做了那么久，啥也没产出，为啥这么懒
- 获取页面的 html 有多少个标签

```js
new Set([...document.querySelectorAll("*")].map((ele) => ele.tagName)).size
```

## 0402

- 1028,63
- 面试经验积累小程序已经开始，现在手忙脚乱，一会接口，一会前端，一会设计，都不知道自己要忙啥。这两天先忙着接口开发和设计
- 前端 pc 页面展示+小程序端页面展示+用户登录

## 0403

- 1029,64
- Nestjs 还是这么菜，看不懂大佬们写的逻辑，后端服务这块写的太少了，羡慕大佬
  [isme-nest-serve](https://github.com/zclzone/isme-nest-serve)
- [unocss](https://juejin.cn/post/7244818201976078394?searchId=202404031810020A05F10C7266198C3445)
- 需要学习的内容有：vue3+pinia+unocss+nestjs
- 最近先把前端所需的服务端上线
- 为了写好自己的接口，不得不继续学习 nestjs+prisma/typeorm，只要干不死就往死里干

## 0404

- 1030，63
- 最近面试系列暂停，需要紧急支持下服务端接口这块，不然怎么成为全栈工程师

## 0405

- 1031,62
- 人总要干成一件事，不然跟废物有啥区别，我最近就要把服务端接口写好，完成最基本的增删改查
- dto.ts 和 entity.ts 两种类型文件是做什么用的
- 微信小程序如何隐藏右上角的胶囊按钮？
- [使用 xshell linux 安装 nodejs,CentOS 下安装并配置 nodejs 环境教程](https://www.cnblogs.com/maqingyuan/p/16574219.html)
- [nvm](https://nodejs.org/en/download/package-manager)
- linux 中如何设置软连接

```bash
-bash-4.2# node -v
v16.16.0
-bash-4.2# npm -v
8.11.0
 ln -s  /etc/node/bin/node  /usr/bin/node
 ln -s  /etc/node/bin/npm  /usr/bin/npm 
```

## 0406

- 1032,61
- [NestJS 学习之优秀项目分析与最佳实践](https://juejin.cn/post/7281570246111576120?searchId=202404061303234D363E19D3DDF005014F)
- DTO（Data Transfer Object）: 数据传输对象，主要目的是转换和验证数据用的，主要在路由控制器中使用。一般是结合[class-validator](https://www.npmjs.com/package/class-validator)使用

  > 还是没理解？

::: info
DTO=Data Transfer Object。Dto 和接口有些类似，但是它的主要目的是为了转换和验证数据。他们基本上在路由控制中被使用。
您可以他们简化您的 API 内容（body）和请求验证逻辑。例如，AuthDto 自动的整合用户的 email 和 password 进一个 dto 对象进行强制验证。

:::

- Nestjs 中的依赖注入原理怎么描述和解释

## 0407

- 1033,60
- typescript 项目中 tsconfig 设置别名

::: info

在 TypeScript 项目中，tsconfig.json 文件用于配置 TypeScript 编译器的选项。通过设置别名（paths），我们可以简化模块导入的路径，使其更加清晰易读，同时也可以解决一些模块解析的问题。

要在 tsconfig.json 中设置别名，你需要在 compilerOptions 对象中使用 paths 属性。paths 属性是一个对象，其中的键是路径的别名（例如 @components/\*），值是一个包含具体路径的数组。下面是如何设置别名的一个例子：

```json
{
  "compilerOptions": {
    "baseUrl": ".", // 这里设置基础路径，所有相对路径都是基于这个路径
    "paths": {
      "@components/*": ["src/components/*"],
      "@services/*": ["src/services/*"],
      "@utils/*": ["src/utils/*"],
      "@constants/*": ["src/constants/*"],
      "@models/*": ["src/models/*"]
    }
  }
}
```

:::

## 0408

- 1034，59
- sse 是什么？

::: details

SSE（Server-Sent Events）是一种允许服务器主动向客户端发送信息的技术。与传统的 HTTP 请求不同，SSE 在客户端建立一个到服务器的单向连接，服务器可以通过这个连接随时发送数据更新。

:::

- [数据库中的关系，关系是指两个或多个表之间的联系。关系基于每个表中的常规字段，通常包含主键和外键。](https://docs.nestjs.cn/10/techniques?id=%e5%85%b3%e7%b3%bb)

- [typeorm 和 nestjs 结合：增删改查](https://docs.nestjs.cn/10/techniques?id=%e6%95%b0%e6%8d%ae%e5%ba%93)

```ts
import { Injectable } from "@nestjs/common"
import { InjectRepository } from "@nestjs/typeorm"
import { Repository } from "typeorm"
import { CreateUserDto } from "./dto/create-user.dto"
import { User } from "./user.entity"

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>
  ) {}

  create(createUserDto: CreateUserDto): Promise<User> {
    const user = new User()
    user.firstName = createUserDto.firstName
    user.lastName = createUserDto.lastName
    return this.usersRepository.save(user)
  }

  async findAll(): Promise<User[]> {
    return this.usersRepository.find()
  }

  findOne(id: number): Promise<User> {
    return this.usersRepository.findOneBy({ id: id })
  }

  async remove(id: string): Promise<void> {
    await this.usersRepository.delete(id)
  }
}
```

## 0409

- 1035, 58
- nestjs 项目中的@nestjs/passport passport passport-local 分别有什么用

- nestjs 项目中，对于参数定义，不能这么定义,这样对于控制器来说已哪个为准？

```ts
export const UserController {
  constructor(
    private userService: Uservice
  ) {}

  @Get(':username')
  findByUsername(@Param('username') username: string) {
    console.log('name');
    return this.userService.findByUsername(username);
  }

  @Get(':id')
  findByUserId(@Param('id') id: number) {
    return this.userService.findOne(id);
  }
}
```

## 0410

- 1036,57
- @JoinTale 和@JoinColumn 区别是啥？

- [如何创建自引用关系](https://www.typeorm.org/relations-faq)

> 分类可以嵌套其他分类，嵌套分类可以嵌套其他分类

```ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  OneToMany,
} from "typeorm"

@Entity()
export class Permission {
  @PrimaryGeneratedColumn()
  id: number

  @Column()
  title: string

  @ManyToOne(() => Permission, (permission) => permission.children, {
    createForeignKeyConstraints: false,
  })
  parent: Permission

  @OneToMany(() => Permission, (permission) => permission.parent, {
    createForeignKeyConstraints: false,
  })
  children: Permission[]
}
```

## 0411

- 1037，56

### 微信静默授权(snsapi_base)和非静默授权(snsapi_userinfo)区别

> [官网文档](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)

- 静默授权：只用来获取用户的 **openid**（用户相对于该服务号的唯一标识），**用户不感知**。并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）
- 非静默授权：用来获取用户的基本信息的。但这种授权需要**用户手动同意**，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。
- 用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户 OpenID 来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即 openid）关注了公众号后，才能调用成功的。

### 微信里 UnionID 机制

- 请注意，网页授权获取用户基本信息也遵循 UnionID 机制。即如果开发者有在多个公众号，或在公众号、移动应用之间统一用户账号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用 UnionID 机制来满足上述需求。
- UnionID 机制的作用说明：如果开发者拥有多个移动应用、网站应用和公众账号，可通过获取用户基本信息中的 unionid 来区分用户的唯一性，因为同一用户，对同一个微信开放平台下的不同应用（移动应用、网站应用和公众账号），unionid 是相同的。

- **forRootAsync** 使用了 TypeORM 的异步工程模式，这样可以解决 imports 的顺序问题，也就是说，使用了 forRootAsync，可以不用在意 imports 这个数组中使用 TypeOrmModule 的顺序，可以任意放，不用在意其他模块引入的顺序

```ts
import { TypeOrmModule } from '@nestjs/typeorm';
@Module({
  imports: [ TypeOrmModule.forRootAsync({})],
  controllers: [],
  providers: []
})
```

## 0412

- 1038，55
- 每天都是煎熬，最难过的莫过于表演，而我又不喜欢表演。
- 降低一切无效社交，老老实实敲代码，搬砖
- “有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了；有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。——泰戈尔”

## 0413/0414

- 1040，53
- 认清自己，谦卑一点，发表意见的时候，仅供参考，多以数据和事实说话，还有就是自己那么忙，没有时间去处理琐事，还是不能放弃学习
- 大模型能专注于只做某一领域吗，做深做透，比如高考规划，利用大模型，打破信息差，什么学校的强基政策以及高校专项计划等各种政策解读，让各种高考规划师面临失业，再比如保险领域，买什么保险是否需要保险等等
- [typeorm 进阶查询](https://typeorm.biunav.com/zh/find-options.html#%E8%BF%9B%E9%98%B6%E9%80%89%E9%A1%B9)

## 0415

- 1041，52
- TypeORM 中的 Like 和 ILike 运算符都用于模糊查询，但它们的区别在于对**大小写**的敏感性。

Like 运算符是区分大小写的。例如，使用 Like '%abc%' 查询时，只会匹配包含 abc 的记录，而不会匹配包含 Abc、ABC 等大小写不同的字符串。

ILike 运算符是不区分大小写的。例如，使用 ILike '%abc%' 查询时，会匹配包含 abc、Abc、ABC 等字符串，无论大小写如何。
