# 202410

::: info

> 2024010 国庆放假回来，不知道前端知识忘记了多少

:::

## 1008

- 1216
- 如何度过这漫长而又苦逼的一生？微笑面对，smile to life
- [Http 请求中增加的新的方法类型](https://mp.weixin.qq.com/s/EKTAYspvloDXiKwaBnwazA),总结起来就是： 1.能承载大量请求数据 2.保证请求的幂等性和安全性。QUERY 是一种安全且幂等的 HTTP 请求方法，它允许携带请求内容。与 GET 方法不同，QUERY 方法并不请求服务器返回指定 URI 资源的表示，而是要求服务器根据请求内容进行查询操作。简单来说，QUERY 方法通过请求体来定义查询操作，并将操作结果作为响应返回。
- [数组解构是如何降低 JavaScript 的运行速度](https://mp.weixin.qq.com/s/HxS-g3ldqhs-y1YE7uWnJA)
- prisma 中的事务是什么？有啥用？
- 想法：现实中买房或者租房成本太高，如果一旦不合适，就要承担高额违约金，就不能推出试用版，试用一周或者两周，都是付费，如果不合适解约就行，也不需要支付这么贵的金额
- 现在企业招聘都要求：有 Node.js 或者 AI 项目开发经验者优先？[招聘目录](https://github.com/ruanyf/weekly/issues/5090)

## 1009

- 1217
- 最难熬的一季，老婆还有最后三个月就要生了，需要额外关照，每年冬天也是公司裁员的高峰期，还要面临被裁员的风险，buffer 叠满，双重压力。感觉压力快赶上上海最黑暗的时刻了。每次产检都紧张的要死要死，希望宝宝一切都好
- [大佬的博客干活满满，值得一读](https://www.ruanyifeng.com/blog/2024/07/copilot-vs-marscode.html)
- “每个人的生活都是一条通向自身的道路。每个人的真正职责只有一个：找到自我。然后在心中坚守一生，全心全意，永不停息。
  所有其它的路都是不完整的，是人的逃避方式，是对社会角色的懦弱伪装，是随波逐流，是对内心的恐惧。”
- 最近  ECMAScript  引入了一个新的提案：proposal-safe-assignment-operator，中文翻译为：安全赋值运算符，代码中是`?=`

```js
const fetchData = async () => {
  const [error, res] ?= (await api.getData().json())
  if (error || !isArray(res)) {
    return []
  }
  return res
}
```

很多人会问，为啥要将  error  放前面，而  result  放后面呢？其实很好理解，因为并不是所有函数执行都会有返回结果的，换句话说：error 是客观存在的，result 是主观存在的，所以  error  放前面更方便，代码判断起来更加舒服

```js
const resolvePromise = () => {
  const count = Math.random()*10
  return new Promise((resolve,reject) => {
    if(count > 5) {
      resolve(count)
    } else {
      reject(count)
    }
  })
}
const [error, res] ?= resolvePromise()
console.log(error, res)
```

## 1010

- 1217
- MemoryRouter 与 BrowserRouter 的区别是什么？

::: info

MemoryRouter 和 BrowserRouter 是 react-router-dom 库中提供的两种不同类型的路由组件，它们在数据持久性和使用场景上有所不同： 1.数据持久性：

BrowserRouter：使用浏览器的历史 API 来管理路由状态，这意味着路由状态会被持久化到浏览器的历史记录中。当你使用 BrowserRouter 时，用户可以通过浏览器的前进和后退按钮来导航到不同的路由状态。
MemoryRouter：路由状态仅存在于内存中，不依赖于浏览器的历史记录。这意味着，当用户刷新页面或者关闭并重新打开浏览器时，MemoryRouter 将不会记住之前的路由状态。

2.使用场景：  
BrowserRouter：适用于大多数 SPA（单页应用程序）场景，因为它与浏览器的历史记录集成，提供了自然的导航体验。
MemoryRouter：适用于不需要持久化路由状态的场景，如：
服务器端渲染（SSR）的应用程序，因为服务器端渲染时没有浏览器环境，所以不能使用 BrowserRouter。
模态对话框或弹出窗口内部的路由，这些组件可能需要自己的路由逻辑，而不干扰主应用程序的路由状态。
测试环境，用于模拟路由行为而不影响全局的路由状态。
临时的、一次性的路由需求，例如，当你需要一个独立的路由实例来展示某个组件，而不希望这个状态被持久化。

:::

- ios 白屏率优化？h5 页面能做啥，该做的缓存和压缩/http2.0/已经有了，还能做啥？
