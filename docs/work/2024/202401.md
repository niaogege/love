# 202401

::: info

> 不知道能不能等到新年到来

> 不幸与幸运，还在目前公司等待新年的到来 20240102

:::

## 0102

- 937
- 我以为回南京或者连云港老家能够安心学习，大错特错，上海才是你好好学习的最佳地点和时间，心无旁骛，冲刺最后一个月

## 0103

- 938
- 看了掘金 N 多个年度总结，90%都是被裁/离职，感觉靠技术生存下去越来越难，要准备副业，很感谢目前所在的公司给予的良好工作环境和氛围，没有裁我，也没欠薪，十分感谢公司
- 带宽怎么计算？
- 响应时间里 TP50/TP90/TP99 分别代表什么？

- TP50 - 50%的请求的响应时间低于这个值。也就是响应时间的中位数。
- TP90 - 90%的请求的响应时间低于这个值。表示只有 10%的请求响应时间超过了这个值。
- TP99 - 99%的请求的响应时间低于这个值。表示只有 1%的请求响应时间超过了这个值。

所以这三个指标从整体上反映了一个服务的响应时间分布情况。TP50 表示中位数,TP90 和 TP99 关注响应时间的尾部分布。一个服务的目标是使这三个指标的值都尽可能低,表示响应时间集中且尾部延迟较低。

- [一文搞懂 Kubernetes 部署策略](https://juejin.cn/post/7319418651069743167)
- [作为前端 leader，怎么快速搭建多环境 CICD 自动化部署？](https://juejin.cn/post/7250083673189253176)

## 0104

- 939,很感谢公司，养活了我这么近，快三年了，又是心存感激的一天
- leetcode 刷题进度不如意，需要加快进度，也不能一棵树吊死，每天刷不同类型的题目。[看到一位大佬，每天上班一天能刷 10 道题，太厉害了，真心佩服](https://leetcode.cn/u/shoarn/)
- Node.js 应用 RSS 内存是指啥？
  Resident Set Size，它表示程序运行时主要占用的物理内存大小,Node.js 应用占用内存大小过大可能表示有内存泄漏或其他问题。常见的原因包括： 1.全局变量或缓存未及时释放 2.闭包导致无法释放变量 3.事件监听器未及时移除 4.大对象频繁分配而不释放,通过以下方法分析和优化 Node.js 应用的 RSS 内存: 1.使用内存 profiler 工具分析内存使用情况,找到问题代码 2.避免全局变量污染,使用完即释放 3.使用流操作处理大文件,避免大对象分配
- jemalloc 是什么?
  jemalloc 是一种高效的内存分配器(memory allocator),主要用于优化程序的内存管理和性能。
  jemalloc 的全称是 jvm malloc,它是 Facebook 开发的一个开源 C/C++库,后来被集成到了许多知名的开源项目中,如 FreeBSD、Firefox 和 Facebook 的 HHVM。

## 0105

- 940
- 继续积累面试题, 插入排序和搜索旋转排序数组

```js
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let j = i;
    while (j > 0 && arr[j - 1] > arr[j]) {
      swap(arr, j - 1, j);
      j--;
    }
  }
  return arr;
}
function swap(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
insertSort([222, 333, 1, 2, 3333, 4, 6, 77]);
// 输入：nums = [4,5,6,7,0,1,2], target = 0
// 输出：4
function trans(nums, target) {
  let l = 0,
    r = nums.length - 1;
  while (l <= r) {
    let mid = l + Math.floor((r - l) / 2);
    if (nums[mid] == target) return mid;
    // 左右分段
    if (nums[l] <= nums[mid]) {
      if (target >= nums[l] && target < nums[mid]) {
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    } else {
      if (target > nums[mid] && target <= nums[r]) {
        l = mid + 1;
      } else {
        r = mid - 1;
      }
    }
  }
  return -1;
}
```

## 0106

- 941
- 继续积累面试题,天天写，其实也没啥用处，只是让自己大脑运转起来

```js
/**
 * 1.螺旋矩阵
 * 2.岛屿数量
 * 3.三数之和
 * 4.接雨水
 * 5.最长递增子序列
 * 6.useRequest
 */
// 螺旋矩阵
// 入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
// 输出：[1,2,3,6,9,8,7,4,5]
function matrix(nums) {
  if (!nnums.length) return [];
  // 上 右 下 左
  let res = [];
  let up = 0;
  let down = nums.length - 1;
  let left = 0;
  let right = nums[0].length - 1;
  while (true) {
    // 往右
    for (let i = left; i <= right; i++) {
      res.push(nums[up][i]);
    }
    if (++up > down) break;
    // 往下
    for (let i = up; i <= down; i++) {
      res.push(nums[i][right]);
    }
    if (--right < left) break;
    // 往左
    for (let i = right; i >= left; i--) {
      res.push(nums[down][i]);
    }
    if (up > --down) break;
    // 往上
    for (let i = down; i >= up; i--) {
      res.push(nums[i][left]);
    }
    if (right < ++left) break;
  }
  return res;
}

// 岛屿数量
// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
// 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
// 此外，你可以假设该网格的四条边均被水包围。
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {
  let isValid = (grid, r, c) => {
    return grid.length > r && grid[0].length > c && r >= 0 && c >= 0;
  };
  let dfs = (grid, r, c) => {
    if (!isValid(grid, r, c) || grid[r][c] != "1") return "0";
    grid[r][c] = "2";
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
  };
  let count = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] == "1") {
        count = count + 1;
        dfs(grid, i, j);
      }
    }
  }
  return count;
};
```

## 0107

- 942
- 不同路径和最小路径总结

## 0108

- 943
- 刷题俩个心路历程：1.不断塑造内心的强大 2.需要时不时的往后总结经验，沉淀一下
