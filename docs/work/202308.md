# 202307

::: info

8 月了，希望自己能重拾信心

- 20230713
  :::

## 0801

- 783
- 网站中的字体图标怎么搞出来的?
- 正则表达式之继续加练

```js
(?<=p) // 符合p子模式后面(注意(?=p)表示的是前面)的那个位置
(?=p) // 符合p子模式前面的那个位置

let str = 'xxx_love'
str.replace(/(?=xxx)/g, 'cpp') // cppxxx_love
str.replace(/(?<=xxx)/g, 'cpp') // xxxcpp_love
```

## 0802

- 784 - 311
- 高效完成开发任务
- 继续默写

## 0803

- 当 getServerSideProps 所在页面为 SSR 服务端渲染时，getServerSideProps 中的数据将会被放到全局的 `_NEXT_DATA` 中，用于 hydrate。
  而非 SSR 情况下，进入该页面 next.js 将会自动发请求到： `\_next/data/development/{url}.json?{query}`，其中 development 为开发环境下地址段，该请求的返回值为：

[作者：嘿嘿不务正业](https://juejin.cn/post/7152531927554064398)

## 0804

- [推荐一个站长工具](https://web-check.xyz/)

阔以采集以下信息：

- ip、SSL 信息
- DNS 解析、域名信息
- cookies
- 网页快照
- 服务器信息
- 页面质量信息（性能、可访问性、最佳实践、SEO...）
- 开放端口

## 0805

- RegExp.$1: 在 JavaScript 中，RegExp.$1 是一个全局的正则表达式属性，它表示正则表达式中**第一个捕获组**（括号中的内容）匹配的结果。

当你使用正则表达式进行匹配时，如果在正则表达式中使用了括号来创建捕获组，那么匹配成功后，捕获组中的内容会被存储在 RegExp.$1 中，而第二个捕获组会存储在 RegExp.$2 中，以此类推。

```js
const text = "Hello world, my name is John.";

// 使用正则表达式匹配名字
const regex = /name is (\w+)/;
const match = regex.exec(text);

if (match) {
  console.log("整个匹配结果:", match[0]); // "name is John"
  console.log("捕获组 1:", match[1]); // "John"
  console.log("RegExp.$1:", RegExp.$1); // "John"
}
```

在上述代码中，正则表达式 /name is (\w+)/ 使用括号创建了一个捕获组，匹配成功后，捕获组中的内容（"John"）会被存储在 **match[1]** 和 RegExp.$1 中。

需要注意的是，RegExp.$1 是一个全局属性，它会在整个 JavaScript 环境中共享，可能会受到其他正则表达式的影响。为了避免混淆和不确定性，最好在匹配之后立即提取捕获组的值并存储在变量中，而不是依赖于全局属性。

- 手写二叉树前中后序迭代遍历

- 手写 jsonp 原理

- 手写前端 history 和 hash 路由
