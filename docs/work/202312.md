# 202312

::: info

马上又年长了 1 岁，可技术没有与之递增，要有紧促感!

> 20231101

> 焦急等待开奖，还不知道路在哪里 2023118

> 20231126 攻克算法

> 20231201 react 框架需要重塑

:::

## 1201

- 905
- [Next.js 14 发布 Server Actions](https://mp.weixin.qq.com/s/d3wnLfJTQvjD_Iy33EMe-A)

> 简单来说， **Server Actions** 可以直接让我们在 JSX 代码中操作 Server 相关的能力。

- 你的问题主要在于读书不多而想得太多。——杨绛

## 1202

- 906,1 月 935 2 月 966 3 月 995 4 月 1026，后续戛然而止
- react 和打包工具八股文整理，背诵
- [阿里前端 p7 面试实战，附答案](https://juejin.cn/post/7243677232836673593#heading-8)

### RAIL(response/animation/idle/load)

RAIL 是一个关于浏览器性能优化的指导原则，它提供了一种系统化的方法来评估和改善网页应用的性能。RAIL 是由 Google 提出的，旨在帮助开发人员更好地理解和优化用户体验。
RAIL 模型的核心理念是将用户的交互操作分解为四个关键阶段：

- 响应(Response)：在 **100 毫秒**以内响应用户的输入，使用户感觉到立即的反馈。这包括处理点击、滚动和触摸等用户交互。

- 动画(Animation)：保持动画流畅并以**每秒 60 帧**的速度进行渲染，以确保动画的平滑度和视觉连续性。

- 空闲(Idle)：利用主线程空闲时间执行后台任务，例如预加载资源、数据获取和计算等，以避免阻塞用户交互。

- 加载(Load)：**在 5 秒内**将页面内容加载完毕，并在此期间提供关键内容，以使用户能够尽快与页面进行交互。

RAIL 模型的目标是在每个阶段都提供良好的用户体验，并确保在关键性能指标上达到可接受的水平。通过使用 RAIL，开发人员可以更有针对性地优化网页应用的性能，提高用户满意度。
需要注意的是，RAIL 模型并不是一种具体的技术或工具，而是一种方法论和指导原则，它可以与其他性能优化技术和工具结合使用，帮助开发人员构建高性能的网页应用。

## 1203

- 907，前端面试几大块：算法/项目/框架 生态/八股文，目前几个缺点，算法题刷的不够多，框架八股文总结的不够好，需要多总结，多背背
  算法和框架两个大子项如何短时间内进步呢？
  > 做好重复记忆和多次训练以及思维导图

## 1204

- 908,时间飞逝，准备已接近一个月，准备还没达到 60%
- [Next.js 实践：从 SSR 到 CSR 的优雅降级](https://juejin.cn/post/7211088034178416701)
  **学一学造轮子**：[next 降级到 csr 渲染](https://github.com/crazyurus/next-ssr-fallback)

- JSX 语法和 template 语法区别

1. JSX 具有 JavaScript 的完整表现力，可以构建非常复杂的组件。但是灵活的语法，也意味着引擎难以理解，无法预判开发者的用户意图，从而难以优化性能。

2.Template 模板是一种非常**有约束**的语言，你只能以某种方式去编写模板。

- Vue3.0 动静结合的 DOM diff

Vue3.0 提出动静结合的 DOM diff 思想，动静结合的 DOM diff 其实是在**预编译阶段**进行了优化。之所以能够做到预编译优化，是因为 Vue core 可以静态分析 template，在解析模版时，整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签和文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。

借助预编译过程，Vue 可以做到的预编译优化就很强大了。比如在预编译时标记出模版中可能变化的组件节点，再次进行渲染前 diff 时就可以跳过“永远不会变化的节点”，而只需要对比“可能会变化的动态节点”。这也就是动静结合的 DOM diff 将 diff 成本与模版大小正相关优化到与动态节点正相关的理论依据。

## 1205

- 909
- 每天做题，刷题，刷到 2 月份(刷到 1 月底就算是成功了一半)，争取把常见的/热门的/常考的背好，真正让你写的时候，不慌，即使有一点没写对，慢慢调试，都是没问题的。量化：时间刷到 2 月份，算法刷到 100 题
- 题目永远刷不完，我深知这一点，所以应该有个觉悟，把核心知识点掌握，理解透，下次再来复习时，理解的速度会快很多，然后不断重复，估计刷个十次八次应该就能记住 80%
- 手写 js,最长公共前缀能写出来真的不容易啊

```js
// 二叉树最大深度
function maxDepth(root) {
  if (!root) return 0;
  let leftH = maxDepth(root.left);
  let rightH = maxDepth(root.right);
  let h = 1 + Math.max(leftH, rightH);
  return h;
}
// 二叉树最小深度
function minDepth(root) {
  if (!root) return 0;
  let leftH = minDepth(root.left);
  let rightH = minDepth(root.right);
  if (root.left != null && root.right == null) {
    return leftH + 1;
  } else if (root.left == null && root.right != null) {
    return rightH + 1;
  }
  return 1 + Math.min(leftH, rightH);
}
// 最长公共前缀
// 输入：strs = ["flower","flow","flight"]
// 输出："fl"
// 横向扫描
var longestCommonPrefix = function (arr) {
  var findLong = (str1, str2) => {
    var len = Math.min(str1.length, str2.length);
    var index = 0;
    while (index < len && str1[index] === str2[index]) {
      index++;
    }
    return str1.substr(0, index);
  };
  if (!arr || arr[0].length == 0) return "";
  var prefix = arr[0];
  for (let i = 0; i < arr.length; i++) {
    let item = arr[i];
    prefix = findLong(prefix, item);
    if (item.length === 0) {
      break;
    }
  }
  return prefix;
};

// 纵向扫描
var longestCommonPrefix = function (arr) {
  if (!arr || arr[0].length == 0) return "";
  var count = arr.length;
  let len = arr[0].length;
  for (let i = 0; i < len; i++) {
    for (let j = 1; j < count; j++) {
      if (i === arr[j].length || arr[0].charAt(i) != arr[j].charAt(i)) {
        return arr[0].substr(0, i);
      }
    }
  }
  return arr[0];
};
```

- 长时间不写 promise，还是会忘记 Promise.resolve/Promise.finally
- 手写 **class 和模拟继承**两个题还是不知道怎么写，怎么调用？跌跌撞撞

```js
function mockExtends(child, parent, staticProp) {
  let proto = Object.create(parent.proptotype);
  proto.constructor = child;
  child.prototype = proto;
  Object.setPrototypeOf(child, parent);
}

const checkNew = function (instance, con) {
  if (!(instance instanceof con)) {
    throw new TypeError(
      `Class constructor ${con.name} cannot be invoked without 'new'`
    );
  }
};
const defineProperties = function (target, obj) {
  for (const key in obj) {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      value: obj[key],
      writable: true,
    });
  }
};
const createClass = function (con, proto, staticAttr) {
  proto && defineProperties(con.prototype, proto);
  staticAttr && defineProperties(con, staticAttr);
  return con;
};
// 用法
function Person(name) {
  checkNew(this, Person);
  this.name = name;
}
var PersonClass = createClass(
  Person,
  {
    getName: function () {
      return this.name;
    },
  },
  {
    getAge: function () {},
  }
);
```

- 问题：如何要表示除了某个单词之外的任意东西呢？某位字符可以是任何东西，但是就是不能是 xxx, 使用 **^** 符号,[强烈推荐](https://juejin.cn/post/7021672733213720613#heading-24),再次推荐一本书[正则表达式](https://github.com/qdlaoyao/js-regex-mini-book/tree/master)

```js
[^abc]
```

常见简写方式：

```js
\d // 数字
\D // 非数字
\w // [0-9a-zA-Z_]
\W // [^0-9a-zA-Z_]
\s // [\t\v\n\r\f]
\S // [^\t\v\n\r\f]
1. {m,} // 至少出现m次
2. {m} // 出现m次
3. ? // 出现0次或者1次，等价于{0,1}
4. + // 至少出现1次,等价于{1,}
5. * // 出现>=0次,等价于{0,}
```

- 贪婪匹配 VS 惰性匹配?正则本身是贪婪的，会尽可能的多匹配符合模式的字符

```js
let regex = /\d{2,5}/g;
let string = "123 1234 12345 123456";
// 贪婪匹配
// string.match(regex) // [ 123, 1234, 12345, 12345 ]

// 惰性匹配
let regex2 = /\d{2,5}?/g;
// string.match(regex) // [ 12, 12, 34, 12, 34, 12, 34, 56  ]
```

量词后面加一个？，即变成了惰性匹配

```js
贪婪量词        惰性量词
{m,n}            {m,n}?
{m,}             {m,}?
?                   ??
+                   +?
*                   *? 
```

## 1206

- 910,与其自我紧张更希望被干掉拿补偿，与其干掉还希望能在继续 🐶1 年
- 算法题这棵大树早晚要被我干掉，在不断重复肌肉记忆的时候，稍微多一丢丢思考就行，要求不高
- 看到了一个牛皮的独立开发者，不仅技术强，产品思维也很厉害[730 天：从 0 到每月 45000 美金](https://mp.weixin.qq.com/s/UCFRVt6Lem6b_zZ5YmjQFw)，看完之后，自己 emo 了很久，对于未来充满迷茫

## 1207

- 每次面试都这么痛苦，为啥呢？能促使你学习，面对自己的不足，不是挺好的一件事，可自己就是那么没用，老是特别紧张，能不能想到一种办法让自己不紧张？

> 痛苦说明自己在进步

- 树转数组

```js
var listTree = [
  {
    id: 1,
    name: "部门1",
    pid: 0,
    children: [
      {
        id: 2,
        name: "部门1-1",
        pid: 1,
        children: [
          {
            id: 4,
            name: "部门1-1-1",
            pid: 2,
            children: [],
          },
        ],
      },
      {
        id: 3,
        name: "部门1-2",
        pid: 1,
        children: [
          {
            id: 5,
            name: "部门1-2-1",
            pid: 3,
            children: [],
          },
        ],
      },
    ],
  },
  {
    id: 6,
    name: "部门2",
    pid: 0,
    children: [
      {
        id: 7,
        name: "部门2-1",
        pid: 6,
        children: [],
      },
    ],
  },
  {
    id: 8,
    name: "部门3",
    pid: 0,
    children: [],
  },
];
// BFS
function treeToArr(tree) {
  if (!tree) return [];
  let queue = [];
  queue = queue.concat(tree);
  let res = [];
  while (queue.length) {
    let cur = queue.shift();
    if (cur.children && cur.children.length) {
      queue = queue.concat(cur.children);
      delete cur.children;
    }
    res.push(cur);
  }
  return res;
}
treeToArr(listTree);
```

## 1208

### 最近一周经历过三场面试，给自己一个清晰的认识，总结来说：

- 框架八股文准备不足(思维导图继续补充完善)
- 算法基础实在太差了，这个任重道远(每天要保持刷算法的节奏)
- 脑子不够灵活，前端解决实际问题能力不够，这方面不是练习就能提升的，很头痛(如何举一反三？)

总结就是 **太笨了**，知识死记硬背，没有太多自己的沉淀，随便出一个稍微变种的题目就能把自己挂了,比如说

```js
// 增加数组原型 group 方法,实现自定义分类
// 预期结果
var result = {
  bigger: [4, 5],
  smaller: [1, 2, 3],
};
var array = [1, 2, 3, 4, 5]; // sorted
var res = array.group((num, index, array) => {
  return num > 3 ? "bigger" : "smaller";
});
```

### 看看人家[三年的面试题](https://mp.weixin.qq.com/s/MYfuUSNS7xIAT4RgZIMv0g?poc_token=HJKJcmWjYrg5NsAJM_kYwsNn0jPlyGgEsQh4RNwX)，比你问的问题难多了，我 7 年自叹不如！

- 你一开始准备 100 道题，后面觉得不够，准备了 150 道 JS 题，你想这下肯定够了吧，谁知道面试的时候，可能需要储备 100\*5 = 500 道题，你就是井底之蛙，啥也不懂，脑子也不够灵活,简直废物一个！
  算法： 300，目前已有 150，每天 2-3 道题，三个月 150 道题差不多
  js: 200，目前已有 140 在补充 60 道题

### 面试官说：你不要太着急，想好了有思路再去下手，总结起来除了话术要循序渐进，还要自己平时多积累，不可能现场在想在总结，这个肯定会有问题，给人一种说话说不全的感觉
