# 202305

::: info

五月了，还不知道路在哪儿？
要做长久打算！

- 20230214

:::

## 0504

- 建立中提及的东西不能一问三不知，需要多复习下
- 了解 rollup/vite 打包构建流程以及相关 plugin 插件，这个都忘得差不多了
  了解 **babel** 编译原理,
  了解 **postcss** 编译原理，实践实践

```js
const postcssFocus = require("postcss-focus");
const postcss = require("postcss");
const fs = require("fs");
// 输入的 css 文件地址
const from = "src/a.css";
const to = "output/a.css";

fs.readFile(from, (err, css) => {
  postcss(postcssFocus)
    .process(css, { from, to })
    .then((result) => {
      console.log(result.css);
    });
});
```

[postcss plugin 模板](https://github.com/postcss/postcss/blob/main/docs/writing-a-plugin.md)

```js
module.exports = (opts = {}) => {
  // Plugin creator to check options or prepare caches
  return {
    postcssPlugin: "PLUGIN NAME",
    // Plugin listeners
    Once(root) {
      // Calls once per file, since every file has single Root
    },
    Declaration(decl) {
      // All declaration nodes
    },
  };
};
module.exports.postcss = true;
```

nextjs 中的 getServerSideProps/getStaticProps 怎么实现的，如何才能实现

- tailwindcss 是如何运行起来的，如果让你设计一个怎么实现

### yalc:Yalc 完美模拟了正式发包装包的流程。可以将本地构建好的包发布到本地全局的 .yalc 文件夹下，也可以将发布在本地的包安装到本地的任何一个项目里。

使用过程：

1.发布本地 npm 包（npm 包根目录下执行）yalc publish --push

2.项目本地包(项目根目录下执行) yalc add myPackage

3.项目本地包更新，执行 yalc update

4.项目删除 npm 包，执行 yalc remove --all

### 静态分析：静态分析不会运行代码，而是通过编译的方式来分析源代码。它的目的不是为了生成目标代码，而是为了提取一些想要的信息，这是和编译的不同之处。

## 0505

### [webpack 打包流程](https://www.zhihu.com/question/473737575/answer/2339126396)

- npm run build 命令也是**通过环境变量调用 bin 脚本**去调用 Node Api 去执行编译打包。

- 手写 Nodejs 中的 **EventEmitter** Api

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }
  // on 订阅
  on(name, cb) {
    const cbs = this.events[name] || [];
    cbs.push(cb);
    this.events[name] = cbs;
  }
  // emit 执行
  emit(name, ...arg) {
    const cbs = this.events[name] || [];
    cbs.forEach((cb) => cb.apply(this, arg));
  }
  // off 取消订阅
  off(name, cb) {
    if (!this.events[name]) return false;
    const cbs = this.events[name] || [];
    const newCbs = cbs.filter((fn) => fn !== cb);
    this.events[name] = newCbs;
  }
  // once单次执行
  once(name, cb) {
    function one(...arg) {
      cb(...arg);
      this.off(name, one);
    }
    this.on(name, one);
  }
}
```

## 0506

- `pm2 start app.js -i max` // 启动进程的时候加上 -i num 就是启动 num 个进程做负载均衡的意思
- `pm2 start app.js --max-memory-restart 1K` // 指定 1k 内存就重启：
- `pm2 start app.js --watch` // 当文件内容改变自动重启：

### tailwindcss 核心代码

```js
import setupTrackingContext from "./lib/setupTrackingContext";
import processTailwindFeatures from "./processTailwindFeatures";
import { findAtConfigPath } from "./lib/findAtConfigPath";

module.exports = function tailwindcss(configOrPath) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [
      function (root, result) {
        // Use the path for the `@config` directive if it exists, otherwise use the
        // path for the file being processed
        configOrPath = findAtConfigPath(root, result) ?? configOrPath;

        let context = setupTrackingContext(configOrPath);

        if (root.type === "document") {
          let roots = root.nodes.filter((node) => node.type === "root");

          for (const root of roots) {
            if (root.type === "root") {
              processTailwindFeatures(context)(root, result);
            }
          }
          return;
        }

        processTailwindFeatures(context)(root, result);
      },
    ].filter(Boolean),
  };
};
module.exports.postcss = true;
```
