# 202307

::: info

7 月了，还不知道路在哪儿？
要做长久打算！

- 20230522

:::

## 0701/0702

## 0703

- front end interview 不能荒废，留与不留只在一瞬间.怎样才能让自己一直保持足够的核心竞争力？

- 又开始写总结，好好回顾，寄希望奇迹 web 端

- 不会爬虫是硬伤，需要学一学？

## 0705

- A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed "javascript:;".

```js
<a href={undefined} />
```

href 的值 给 **undefined** 即可

- 工作复盘又开始了，回顾半年来的工作重点和成效，真不理解一个搞技术的要背业务绩效的指标，难以理解
- 配置网关有什么作用，如果不配置网关会有什么后果
  访问 xxx.bythewayer.com/xx -> nginx -> 网关 -> 应用服务器
- [node 服务治理](https://zhuanlan.zhihu.com/p/399510723)

## 0706

- 宝贝生日快乐，25 岁了

## 0707

- H1 工作总结和项目回归，讲的还是有点急躁，下次一定要慢一点说
- 工作内容产出不是很多，我感觉杰哥一个人搞得定所有 seo 相关的开发，他一个人绰绰有余，我显得有点多余

## 0710

- 跟对象一起去看了电影《消失的她》
- 最近工作任务蛮重，好像没啥时间来记录生活的琐碎
- http 请求 header 中的**x-powered-by**不是 Apache 或者 Nginx 输出的，而是由**语言解析器或者应用程序框架**输出的, 这个值的意义用于告知网站是用何种语言或框架编写的,如果使用 php 写的，即输出是：X-Powered-By: PHP/7.0.27; 如果使用 nodejs 中的 Nextjs 框架运行的页面，则会显示 X-Powered-By: Next.js

## 0711

- 推荐一个 免费的 AI 工具 https://www.phind.com/ -》 [phind: 专注于开发者的 AI 搜索引擎诞生！](https://mp.weixin.qq.com/s/_FLYl23pRacRBaI4_nf7Pg)

- nodejs 中如何用 fetch 获取数据

```js
const fetch = require("node-fetch");

fetch("https://api.github.com/users/github")
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.log(error));
```

如果不使用第三方库的话，使用原生 fecth api 的话，需要满足 1.nodejs 版本大于 17.5 2.执行 nodejs 脚本的时候带上实验性参数

```js
node --experimental-fetch your_code.js
```

- 读取 excel 表格，完成数据请求， 然后写入表格新内容, ，需要用到一个 nodejs 库[node-xlsx](https://www.npmjs.com/package/node-xlsx)

```js
/**
 * node读取excel数据
 * 请求接口 然后填充数据
 */
import fetch from "node-fetch";
import fs from "fs";
import os from "os";
import xlsx from "node-xlsx";

const homedir = os.homedir() + "/Desktop/";
const outputName = "albumId-output.xlsx";

// 读取文件
const fileName = "albumId2.xlsx";
const workSheetsFromBuffer = xlsx.parse(fs.readFileSync(homedir + fileName));

// 请求后端数据
const getData = async (kw) => {
  const url = `http://xxx.xx?&kw=${kw}`;
  const data = await fetch(url);
  return data;
};
async function genData() {
  const sheetData = workSheetsFromBuffer[0].data; // 第一个sheet表单的数据
  for (let i = 1; i < sheetData.length; i++) {
    const item = sheetData[i];
    try {
      const response = await getData(item[1]);
      const data = await response.json();
      const docs = data.data.album.docs;
      const albumId = docs[0].albumId;
      const title = docs[0].title;
      sheetData[i].push(albumId);
      sheetData[i].push(title);
    } catch (e) {
      console.log(e, "eee");
    }
  }
  return [{ name: "test1", data: sheetData }];
}

genData().then((res) => {
  // 自定义列宽
  const sheetOptions = {
    "!cols": [{ wch: 6 }, { wch: 7 }, { wch: 10 }, { wch: 20 }],
  };
  // 生成表格数据对象
  const buffer = xlsx.build(res, sheetOptions);
  // 生成excel 写入表格
  fs.writeFile(homedir + outputName, buffer, (err) => {
    if (err) throw err;
    console.log(`
    --------- ---------生成完毕--------- ---------
        请在桌面查找 ${outputName}
    ---------如需配置生成路径或文件名,请配置output---------
    `);
  });
});
```

## 0712

- `document.all` 输出当前页面的所以节点，`typeof document.all === undefined`
- **反向代理** 客户端无法感知代理，因为客户端访问网络不需要配置，只要把请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据，然后再返回到客户端。此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了**真实服务器 IP 地址**。

- 基于 **upstream** 做负载均衡,中间会涉及一些相关的策略比如 ip_hash、weight。nginx 负载均衡方式如下： 1.轮询（默认）。
  2.weight，代表权，权越高优先级越高。
  3.fair，按后端服务器的响应时间来分配请求，相应时间短的优先分配。
  4.ip_hash，每个请求按照访问 ip 的 hash 结果分配，这样每一个访客固定的访问一个后端服务器，可以解决 Session 的问题。

- 好文推荐[React Context 的核心实现，就 5 行代码](https://mp.weixin.qq.com/s/qpQS3ne7HXSL5Dle-ts4qQ)

## 0713

- 手写六月份背诵的面试题

```js
Array.prototype.myReduce = function (fn, init) {};
Function.prototype.mockApply = function (fn, ...rest) {};
Function.prototype.mockBind = function (fn, ...rest) {};
function mockNew(fn, context) {}
class LRU {}
function curry(fn) {}
var add = function (...rest) {
  return rest.reduce((a, b) => a + b);
};

function compose(middlewares) {}
function bigInt(a, b) {}
function rgbToHex(str) {}
function hexToRgb(str) {}
```

- 匹配 url 里的参数信息

```js
var url = "?tt=111&uid=123&shareTime=123";
var regex = /[?&]uid=([^&]+)/;
var match = regex.exec(url);
var uid = match && decodeURIComponent(match[1]);

console.log(uid); // 输出：123
```

## 0714

- HttpDNS 是一种用于解析域名（Domain Name System）的替代方案，它通过使用**HTTP 协议**而不是传统的 DNS 协议来获取域名对应的 IP 地址。

传统的 DNS 解析过程中，客户端通过向 DNS 服务器发送 DNS 请求，获取域名对应的 IP 地址。然而，DNS 请求的过程可能会受到网络环境的影响，例如 DNS 劫持、DNS 污染等问题，导致域名解析不准确或延迟。

HttpDNS 的工作原理是将域名解析的过程放在了 HTTP 请求中完成。客户端发送一个 HTTP 请求到 HttpDNS 服务器，其中包含需要解析的域名信息。HttpDNS 服务器根据接收到的 HTTP 请求中的域名信息，返回对应的 IP 地址作为响应。客户端接收到 IP 地址后，可以直接使用该地址进行网络通信，无需再进行传统的 DNS 解析过程。

使用 HttpDNS 的好处是可以避免传统 DNS 解析过程中可能遇到的劫持、污染等问题，提高域名解析的准确性和速度。特别是在移动设备网络环境不稳定或存在防火墙限制的情况下，HttpDNS 可以提供更好的解析效果。

要使用 HttpDNS，您需要访问相应的 HttpDNS 服务提供商，并根据其提供的文档和 API，将 HTTP 请求发送到 HttpDNS 服务器，并解析返回的 IP 地址。每个 HttpDNS 服务提供商可能有不同的实现细节和要求，因此具体的使用方式可能会有所差异。

以下是一个简单的示例，展示如何使用 HttpDNS 来获取域名对应的 IP 地址：

```js
var dnsUrl = "http://your-httpdns-provider.com/dns-query";
var domain = "example.com";

// 发送HTTP请求到HttpDNS服务器
fetch(dnsUrl + "?name=" + domain)
  .then(function (response) {
    return response.json();
  })
  .then(function (data) {
    var ipAddress = data.ips[0]; // 假设返回的IP地址数组中的第一个为主IP地址
    // 使用获取到的IP地址进行网络通信
    // ...
  })
  .catch(function (error) {
    console.log("Error: " + error);
  });
```

在上面的示例中，我们使用了 Fetch API 来发送 HTTP 请求到 HttpDNS 服务器，并解析返回的 JSON 格式数据，获取域名对应的 IP 地址。然后可以使用获取到的 IP 地址进行后续的网络通信操作。

请注意，上述示例仅为演示 HttpDNS 的基本原理，实际使用中您需要根据具体的 HttpDNS 服务提供商的要求来构建和发送 HTTP 请求，并处理返回的数据。

## 0715

- [koa 中的路径重定向](http://www.koajs.com.cn/)

```js
const server = new Koa();
server.use(async (ctx, next) => {
  if (ctx.request.url === "/cpp") {
    ctx.status = 302;
    ctx.redirect("/ranking");
    ctx.body = "Redirecting to shopping cart";
  } else {
    await next();
  }
});
```

## 0716

人生中的第 32 个生日，199107-202307

大学毕业的第九个年头，2014-2023 23-32 明年就是毕业第十年了，依然还是一无所有，碌碌无为

41 + 43 + 26 110 个月 不知道在现在的处境下 还能呆多久

## 0717

- 梦到自己失业了，被自己惊醒，在这个不上不下的年纪，失业是早晚的事，我要做的就是在失业前有足够的底气，也就是资本。

现在处境很尴尬，什么都是一成不变，我不允许自己这样。总要学点东西，不能辜负这大美光阴，之前心心念的爬虫抓取，阔以学习下

- atob() 对经过 base-64 编码的字符串进行解码。你可以使用 window.btoa() 方法来编码一个可能在传输过程中出现问题的数据，并且在接受数据之后，使用 atob() 方法再将数据解码。例如：你可以编码、传输和解码操作各种字符，比如 0-31 的 ASCII 码值。

```js
let encodedData = window.btoa("Hello, world"); // 编码
let decodedData = window.atob(encodedData); // 解码
```

## 0718

- 知乎上看到一个很悲伤的话题，[如果父母都不在了 我还会回故乡吗](https://www.zhihu.com/question/575489954)

### Nextjs 13.0 版本里的数据预取方式 [Static Data Fetching](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching#static-data-fetching)

- Static Data Fetching 静态数据获取

By default, fetch will automatically fetch and cache data indefinitely.

```js
fetch("https://..."); // cache: 'force-cache' is the default 相当于之前的getStaticProps
```

- Revalidating Data 重新验证数据
  To revalidate cached data at a timed interval, you can use the next.revalidate option in fetch() to set the cache lifetime of a resource (in seconds). next.revalidate 选项设置资源的缓存生存期（以秒为单位）

```js
fetch("https://...", { next: { revalidate: 10 } });
```

- Dynamic Data Fetching 动态获取数据 相当于之前的 getServerSideProps
  To fetch fresh data on every fetch request, use the cache: 'no-store' option 每次请求的时候都用最新的数据 阔以设置 fetch 中的 no-store 选项

```js
fetch("https://...", { cache: "no-store" });
```
