# 202311

::: info

不知道路在哪里？路在脚下，可脚下却无路可走

> 20231101

:::

## 1101

- react 版本的元素露出与隐藏以及**IntersectionObserver** API

```js
  const ExposeRef = useRef(
    new IntersectionObserver(
      (entries) => {
        entries.forEach(({ intersectionRatio, target }) => {
          if (intersectionRatio > 0.5) {
            const _target = target as HTMLImageElement;
            const ids = _target.dataset.expose ?? "";
            console.log(ids, "ids");
            setShowIndex(+ids);
          }
        });
      },
      {
        root: null,
        threshold: 0.7,
      }
    )
  );

  useEffect(() => {
    const exposeRef = ExposeRef.current;
    const everyItems = document.querySelectorAll("[data-expose]");
    if (everyItems && everyItems.length) {
      Array.from(everyItems).forEach((item) => {
        if (item) {
          exposeRef.observe(item);
        }
      });
    }
    return () => {
      exposeRef.disconnect();
    };
  }, []);
```

- js 正则表达式利用

```js
str.replace(/(\?age=)(12|57)/g, "age=28");
```

### [browserslist 原理](https://mp.weixin.qq.com/s/js85Lq4mU2XB3pFSuUKhag)

browserslist[2] 用特定的语句来查询浏览器列表，如 last 2 Chrome versions。

```js
npx browserslist "last 2 Chrome versions"
```

细说起来，「它是现代前端工程化不可或缺的工具，无论是处理 JS 的 babel，还是处理 CSS 的 postcss，凡是与垫片相关的，他们背后都有 browserslist 的身影。」

- babel，在 **@babel/preset-env** 中使用 core-js 作为垫片
- postcss 使用 **autoprefixer** 作为垫片

关于前端打包体积与垫片关系，我们有以下几点共识:

- 由于低浏览器版本的存在，垫片是必不可少的
- 垫片越少，则打包体积越小
- 浏览器版本越新，则垫片越少
- 那在前端工程化实践中，当我们确认了浏览器版本号，那么它的垫片体积就会确认。

假设项目只需要支持最新的两个谷歌浏览器。那么关于 browserslist 的查询，可以写作 last 2 Chrome versions。

而随着时间的推移，「该查询语句将会返回更新的浏览器，垫片体积便会减小。」

#### 谈一下 browserslist 的原理

browserslist 根据正则解析查询语句，对浏览器版本数据库 **caniuse-lite** 进行查询，返回所得的浏览器版本列表。

#### 一些常用的查询语法

- 浏览器版本号： Chrome > 90: Chrome 大于 90 版本号的浏览器
- 根据最新浏览器版本

```js
last 2 versions: 所有浏览器的最新两个版本
last 2 Chrome versions: Chrome 浏览器的最新两个版本
```

- 根据用户份额:

```js
> 5%: 在全球用户份额大于 5% 的浏览器
> 5% in CN: 在中国用户份额大于 5% 的浏览器
```

## 1102

- 每个 js 对象都有 toString()方法,单纯的数字.toString(16)会报语法错误

```js
16.toString(16)
// Uncaught SyntaxError: Invalid or unexpected token
var test = 16
var text1 = test.toString(16)
console.log(text1)
// 10 ok
```

- 好文推荐[浏览器和图形引擎渲染对比](https://mp.weixin.qq.com/s/Ptxs-3d_cSb4SrC4bhO2Ig)

## 1103/1104

### [三分钟，教你 3 种前端埋点方式！](https://mp.weixin.qq.com/s/ff5HxRcnADy34p_zArzq8A)

## 1105

- 年底了 各地都在裁员，如何让自己处于主动点呢，唯有周末好好复习
- 一周花 500，一个月需要花掉 2000，加上房租 2500，房贷 6200，一个月最基本的开销都要 10700，我的妈呀，4500+2800 = 7300

## 1106/1107

- [字节 PICO 裁员](https://maimai.cn/n/content/global-topic?circle_type=9&topic_id=k50Jr4hl&_share_channel=wechat&share_from=wx)，心有不甘
- [谈谈 node 架构中的线程进程的应用场景、事件循环及任务队列](https://mp.weixin.qq.com/s/huyn95OyOz45J93B3WGXdA)
- 学会使用[easy-monitor](https://www.yuque.com/hyj1991/easy-monitor/deployment)

## 1108/1109

- 当你要覆写某个原生方法时，为了防止他已经被其他库覆写（这样你覆写的就不是原生的那个），可以从 iframe 里取（比如图中取 Array.from）
  这个方法是从@sodatea 的一个 issue 中看到的 (from 卡颂)

```js
const iframe = document.body.appendChild(document, createElement("iframe"));
const iframeArray = iframe.contentwindow.Array;
document.body.removeChild(iframe);
Array.from = iframeArray.from;
```

- [让 CSS 官方后悔的一些决定](https://mp.weixin.qq.com/s/YuelqFfTPG58-_uXsptK6Q)
- [应用题](https://mp.weixin.qq.com/s/LotI0aQbJtBZHVgQH2bVBg)

```js
const data = [
  { userId: 8, title: "title1" },
  { userId: 11, title: "other" },
  { userId: 15, title: null },
  { userId: 19, title: "title2" },
];

// 查找data中，符合where中条件的数据，并根据orderBy中的条件进行排序
const result = find(data)
  .where({
    title: /\d$/, // 这里意思是过滤出数组中，满足title字段中符合 /\d$/的项
  })
  .orderBy("userId", "desc"); // 这里的意思是对数组中的项按照userId进行倒序排列

//=> 返回 [{ userId: 19, title: 'title2'}, { userId: 8, title: 'title1' }];
console.log(result.value);
```

## 1110

- 写一个健康检查的中间件

```js
module.exports = async function (ctx, next) {
  if (/share\/healthcheck/.test(ctx.path)) {
    ctx.body = "healthcheck success";
    return;
  }
  await next();
};
```

## 1113

- [Prisma：作为迁移和数据库访问的 ORM?](https://prisma.yoga/getting-started/quickstart)
  > Prisma 和 ROM 完全不懂
- 解释下 orm?

> ORM，全称为 Object-Relational Mapping，即对象关系映射，是一种编程技术，用于将数据库中的数据转换为对象，以便在编程语言中使用。它是一种设计模式，用于在关系数据库管理系统（RDBMS）和面向对象编程语言之间建立映射。

ORM 的主要目标是消除在数据库和编程语言之间转换数据时的差异。它允许开发人员使用他们熟悉的编程语言来操作数据库，而不需要直接编写 SQL 语句。这样可以提高开发效率，同时也可以减少因为手动编写 SQL 语句而引发的错误。

- 重启 mysql 数据库

```shell
sudo systemctl start mysqld
sudo systemctl stop mysqld
sudo systemctl restart mysqld

# 远程直连
mysql -h 111.230.199.157  -u root -p -P 3306
```
