# 202303

金三银四，三月是人员变动比较频繁的一个月！:broken_heart:

## 0301

::: danger

算法能不能进一步点?? 灵魂拷问？？
:::

- vitepress 头部 head 设置,阔以设置 icon 和 meta

```js
  head: [
    ['link', { rel: 'icon', type: 'image/svg+xml', href: '/logo.svg' }],
    ['link', { rel: 'icon', type: 'image/png', href: '/logo.png' }],
    [
      'meta',
      { name: 'wwads-cn-verify', content: '5878a7ab84fb43402106c575658472fa' },
    ],
    ],
  ],
```

- Web Components 概念

Web Components 是一组标准化的**浏览器 API**，它们可以帮助我们创建可重用的组件。使用 Web Components，我们可以将一个组件封装在一个自定义元素中，并且可以在多个项目中重复使用这个组件。

Web Components 主要包括四个 API：**Custom Elements**、Shadow DOM、HTML Templates 和 HTML Imports。其中

- Custom Elements 允许我们创建自定义元素，
- Shadow DOM 允许我们创建封装的 DOM 节点，
- HTML Templates 允许我们创建可重复使用的模板，
- HTML Imports 允许我们导入 HTML 文件并在页面中使用它们。

## 0302

### 前端设计模式之工厂模式

工厂模式通俗点说就是：更方便地去创建实例

```js
class Axios {}
class Factory {
  create() {
    return new Axios();
  }
}
const axios = new Factory();
export default axios;
// 创建实例
const httpRequest1 = axios.create();
const httpRequest2 = axios.create();
const httpRequest3 = axios.create();
```

### 单例模式

定义一个类，生成一个实例，并且整个项目仅此这一个实例，封装一个请求的 Axios 实例然后暴露出去

```js
// utils/request.js
// 定义一个类
class HttpRequest {
  instance: AxiosInstance;
  constructor(options: CreateAxiosOptions) {
    this.instance = axios.create(options)
  }
  setHeader() {...}
  get() {...}
  post() {...}
  put() {...}
  delete() {...}
}
// 生成一个实例
const request = new HttpRequest({})

// 全局仅用这么一个请求实例
export default request
```

然后在项目中各处去使用这一个请求实例

```js
import request '@/utils/request'

const fetchData = (url) => {
  return request.get(url)
}
```

### 适配器模式

核心： 将一种格式适配成你所需要的格式

比如有一个场景：后端给你返回了三种数据格式，但是你需要把这三种格式转成你前端所需要的格式

```js
// 格式1
const data1 = [{ age1: 20, name1: "林三心" }];
// 格式2
const data2 = [{ age2: 20, name2: "林三心" }];
```

这个时候你需要定义几个适配器类

```js
class Adapter1 {
  data: { age1: number, name1: string }[];
  constructor(data) {
    this.data = data;
  }
  transform() {
    return this.data.map(({ age1, name1 }) => ({
      age: age1,
      name: name1,
    }));
  }
}

class Adapter2 {
  // 同理
}
```

当你需要转换成你需要的数据时，调用这些类就行

```js
const adapter1 = new Adapter1(data1);
// 适配成功
const data = adapter1.transform();
```

### 观察者模式

核心：定义对象间的**一种一对多的依赖关系**，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知

我们平时使用的框架 Vue，它的响应式就是基于观察者模式去做的，下面是简单展示一下它的原理

```ts
class Subject {
  count: number;
  observers: any[];
  constructor() {
    this.count = 0;
    this.observers = [];
  }
  getCount() {
    return this.count;
  }
  setCount(count: number) {
    // 设置值之后通知更新
    this.count = count;
    this.notify();
  }
  notify() {
    this.observers.forEach((o) => {
      o.update();
    });
  }
  push(o) {
    this.observers.push(o);
  }
}

class Observer {
  private name;
  private subject;
  constructor(name: string, sub: Subject) {
    this.name = name;
    this.subject = sub;
    this.subject.push(this);
  }
  update() {
    console.log(`${this.name} 变了 ${this.subject.getCount()}`);
  }
}
const sub = new Subject();
// 观察一号
const observer1 = new Observer("一号", sub);
// 观察二号
const observer2 = new Observer("二号", sub);

sub.setCount(1);
// 一号 变了 1
// 二号 变了 1
```

### 发布订阅模式

发布订阅模式跟观察者模式很像，他们其实都有发布者和订阅者，但是他们是有区别的
观察者模式的发布和订阅是互相依赖的
发布订阅模式的发布和订阅是不互相依赖的，因为有一个统一调度中心

Vue EventBus 就是用了发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.cache = {};
  }
  on(name, fn) {
    const tasks = this.cache[name];
    if (tasks) {
      this.cache[name].push(fn);
    } else {
      this.cache[name] = [fn];
    }
  }
  off(name, fn) {
    const tasks = this.cache[name];
    if (task) {
      const index = tasks.findIndex((item) => item === fn);
      if (index >= 0) {
        this.cache[name].splice(index, 1);
      }
    }
  }
  emit(name, ...args) {
    // 复制一份。防止回调里继续on，导致死循环
    const tasks = this.cache[name].slice();
    if (tasks) {
      for (let fn of tasks) {
        fn(...args);
      }
    }
  }
  once(name, cb) {
    function fn(...args) {
      cb(args);
      this.off(name, fn);
    }
    this.on(name, fn);
  }
}

const eventBus = new EventEmitter();
// 组件一
eventBus.on("event", (val) => {
  console.log(val);
});
// 组件二
eventBus.emit("event", "params");
```

## 0303

- :+1:好文推荐，[cjs 跟 esm 互相转换](https://juejin.cn/post/7205897684624474168)

- [fix unknown rule @tailwindcss ](https://flaviocopes.com/fix-unknown-at-rule-tailwind/)

## 0304

- [tailwindcss 入坑中，需要逐渐熟悉以及学会基本配置](https://www.tailwindcss.cn/docs)

## 0305

- tailwindcss 中如何进行主题模式切换[手动切换深色模式](https://www.tailwindcss.cn/docs/dark-mode)

```html
<!-- Dark mode enabled -->
<html class="dark">
  <body>
    <!-- Will be black -->
    <div class="bg-white dark:bg-black">
      <!-- ... -->
    </div>
    <script>
      // On page load or when changing themes, best to add inline in `head` to avoid FOUC
      if (
        localStorage.theme === "dark" ||
        (!("theme" in localStorage) &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("dark");
      } else {
        document.documentElement.classList.remove("dark");
      }
      // Whenever the user explicitly chooses light mode
      localStorage.theme = "light";
      // Whenever the user explicitly chooses dark mode
      localStorage.theme = "dark";

      // Whenever the user explicitly chooses to respect the OS preference
      localStorage.removeItem("theme");
    </script>
  </body>
</html>
```

## 0306

- 今天老铁问我要不要去他们那边，那边留有一个高级的 HC,我还是没有准备好，那到底啥时候准备好？明明知道自己的劣势和缺点，为啥就不能在努力准备准备呢？

> 问问自己，是否真的已经足够努力了？是否对得起自己对前端的这份热爱？

### 函数柯里化

[一个多参数的函数转换成多个嵌套的单参数函数](https://mp.weixin.qq.com/s/8FmjffUnWx49LsyJn28XdA)

```js
function add(a, b, c, d) {
  return a + b + c + d;
}
// expected
curry(add)(1)(2)(3)(4);

function curry(target) {
  return function fn(...rest) {
    if (target.length === rest.length) {
      return target.apply(null, rest);
    } else {
      // return fn.bind(null, ...rest)
      return (...arg) => fn(...arg, ...rest);
    }
  };
}
// 参数不固定
function curry2(target) {
  var arr = [];
  return function fn(...arg) {
    if (arg.length) {
      arr.push(...arg);
      return fn;
    } else {
      var value = target.apply(null, arr);
      arr = [];
      return value;
    }
  };
}
const add2 = (...rest) => {
  return rest.reduce((acc, cur) => cur + acc, 0);
};
curry2(add2)(1)(2)(3)();
```

## 0307

- 多重循环中嵌套异步函数最佳实践？

- 猜猜打印顺序

```js
async function jackson() {
  console.log(await Promise.resolve("jackson"));
}
async function bear() {
  console.log(await "bear");
}
async function daxiong() {
  console.log("daxiong");
}
jackson();
bear();
daxiong();
```

- 图片裁剪？ctx.drawImage()

原图像从坐标 (33,71) 处截取一个宽度为 104 高度为 124 的图像。并将其绘制到画布的 (21, 20) 坐标处，并将其缩放为宽 87、高 104 的图像。

```js
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const image = document.getElementById("source");

image.addEventListener("load", (e) => {
  ctx.drawImage(image, 33, 71, 104, 124, 21, 20, 87, 104);
});
```

- 更新了下自己的简历，真想加这两句话？hhhh,我真的太自恋了，希望假以时日吧

```md
- 精通 react
- 精通 ssr
```

> 实力配不上我的野心？？？how to do?

什么时候我才能像三元大佬，岀一版自己的小册子[基于 Vite 的 SSG 框架开发实战](https://juejin.cn/video/7163857336258265102?scrollMenuIndex=0)

## 0308

- :100: [前端构建工具进化历程](https://mp.weixin.qq.com/s/o8B8HAczZtIZM8V_HHwNqg)

> 字节出品 感觉就不一样，还是太厉害了，膜拜膜拜

什么是构建？简单来说：构建就是将开发环境的代码转化成生产环境可用来部署的代码。为了生产出生产环境可用的 JS、CSS，构建工具实现了诸如：**代码转换、代码压缩、tree shaking、code spliting** 等。

## 0309

- [vue2 和 vue3 响应式区别](https://mp.weixin.qq.com/s/FGTy5oUAzpCQizZJKJNoMw)

  > 手写 Observer/watcher

- [react 灵魂拷问 23 个](https://mp.weixin.qq.com/s/yPJ4mwTxm-WEFAv2h4SL8Q)
  > 我感觉自己回答 5 个,看到了才能回想起来，总结来说还是没有掌握

## 0310

- 个人主题首页还没有整完，这速度也太慢了！！！自己开发效率太慢了

## 0311

- 去了一趟常州，累个半死，:mask:,来回车票花销 300
- 结婚前的婚纱照拍摄需要提上日程，最迟这周五确定，还要确定的是婚庆相关的事宜
- 确定提亲的日子，提什么亲？

## 0312

- 结婚事宜女方这边难以推进，艰难
- 手写各种排序

```js
// bubble sort
```

## 0313

- 突发奇想：如果从银行里借 10 万用于提前还房贷，这个每个月能少 500 的利息，银行十万一个月 400 的利息，这样每个月还你少还 100 左右的利息
- [react 每日小记](https://zhuanlan.zhihu.com/p/608959809)
  jsx 会被编译成 render function，也就是类似 React.createElement 这种。所以之前写 React 组件都必须有一行 **import \* as React from 'react'**，因为编译后会用到 React 的 api。但后来改为了这种 render function：

```js
const Test = <div>THis is Test</div>;
```

由 babel、tsc 等编译工具自动引入一个 **react/jsx-runtime** 的包.
vdom 转 fiber 的流程叫做 reconcile，我们常说的 diff 算法就是在 reconcile 这个过程中.经过 reconcile 之后，就有了新的 fiber 树了.

react 渲染流程整体分为两个大阶段： render 阶段和 commit 阶段。

- render 阶段也就是 **reconcile 的 vdom 转 fiber 的过程**

- commit 阶段就是具体操作 dom，以及执行副作用函数的过程。commit 阶段还分为了 3 个小阶段：before mutation、mutation、layout。
