# 202303

金三银四，三月是人员变动比较频繁的一个月！:broken_heart:

## 0301

::: danger

算法能不能进一步点?? 灵魂拷问？？
:::

- vitepress 头部 head 设置,阔以设置 icon 和 meta

```js
  head: [
    ['link', { rel: 'icon', type: 'image/svg+xml', href: '/logo.svg' }],
    ['link', { rel: 'icon', type: 'image/png', href: '/logo.png' }],
    [
      'meta',
      { name: 'wwads-cn-verify', content: '5878a7ab84fb43402106c575658472fa' },
    ],
    ],
  ],
```

- Web Components 概念

Web Components 是一组标准化的**浏览器 API**，它们可以帮助我们创建可重用的组件。使用 Web Components，我们可以将一个组件封装在一个自定义元素中，并且可以在多个项目中重复使用这个组件。

Web Components 主要包括四个 API：**Custom Elements**、Shadow DOM、HTML Templates 和 HTML Imports。其中

- Custom Elements 允许我们创建自定义元素，
- Shadow DOM 允许我们创建封装的 DOM 节点，
- HTML Templates 允许我们创建可重复使用的模板，
- HTML Imports 允许我们导入 HTML 文件并在页面中使用它们。

## 0302

### 前端设计模式之工厂模式

工厂模式通俗点说就是：更方便地去创建实例

```js
class Axios {}
class Factory {
  create() {
    return new Axios();
  }
}
const axios = new Factory();
export default axios;
// 创建实例
const httpRequest1 = axios.create();
const httpRequest2 = axios.create();
const httpRequest3 = axios.create();
```

### 单例模式

定义一个类，生成一个实例，并且整个项目仅此这一个实例，封装一个请求的 Axios 实例然后暴露出去

```js
// utils/request.js
// 定义一个类
class HttpRequest {
  instance: AxiosInstance;
  constructor(options: CreateAxiosOptions) {
    this.instance = axios.create(options)
  }
  setHeader() {...}
  get() {...}
  post() {...}
  put() {...}
  delete() {...}
}
// 生成一个实例
const request = new HttpRequest({})

// 全局仅用这么一个请求实例
export default request
```

然后在项目中各处去使用这一个请求实例

```js
import request '@/utils/request'

const fetchData = (url) => {
  return request.get(url)
}
```

### 适配器模式

核心： 将一种格式适配成你所需要的格式

比如有一个场景：后端给你返回了三种数据格式，但是你需要把这三种格式转成你前端所需要的格式

```js
// 格式1
const data1 = [{ age1: 20, name1: "林三心" }];
// 格式2
const data2 = [{ age2: 20, name2: "林三心" }];
```

这个时候你需要定义几个适配器类

```js
class Adapter1 {
  data: { age1: number, name1: string }[];
  constructor(data) {
    this.data = data;
  }
  transform() {
    return this.data.map(({ age1, name1 }) => ({
      age: age1,
      name: name1,
    }));
  }
}

class Adapter2 {
  // 同理
}
```

当你需要转换成你需要的数据时，调用这些类就行

```js
const adapter1 = new Adapter1(data1);
// 适配成功
const data = adapter1.transform();
```

### 观察者模式

核心：定义对象间的**一种一对多的依赖关系**，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知

我们平时使用的框架 Vue，它的响应式就是基于观察者模式去做的，下面是简单展示一下它的原理

```ts
class Subject {
  count: number;
  observers: any[];
  constructor() {
    this.count = 0;
    this.observers = [];
  }
  getCount() {
    return this.count;
  }
  setCount(count: number) {
    // 设置值之后通知更新
    this.count = count;
    this.notify();
  }
  notify() {
    this.observers.forEach((o) => {
      o.update();
    });
  }
  push(o) {
    this.observers.push(o);
  }
}

class Observer {
  private name;
  private subject;
  constructor(name: string, sub: Subject) {
    this.name = name;
    this.subject = sub;
    this.subject.push(this);
  }
  update() {
    console.log(`${this.name} 变了 ${this.subject.getCount()}`);
  }
}
const sub = new Subject();
// 观察一号
const observer1 = new Observer("一号", sub);
// 观察二号
const observer2 = new Observer("二号", sub);

sub.setCount(1);
// 一号 变了 1
// 二号 变了 1
```

### 发布订阅模式

发布订阅模式跟观察者模式很像，他们其实都有发布者和订阅者，但是他们是有区别的
观察者模式的发布和订阅是互相依赖的
发布订阅模式的发布和订阅是不互相依赖的，因为有一个统一调度中心

Vue EventBus 就是用了发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.cache = {};
  }
  on(name, fn) {
    const tasks = this.cache[name];
    if (tasks) {
      this.cache[name].push(fn);
    } else {
      this.cache[name] = [fn];
    }
  }
  off(name, fn) {
    const tasks = this.cache[name];
    if (task) {
      const index = tasks.findIndex((item) => item === fn);
      if (index >= 0) {
        this.cache[name].splice(index, 1);
      }
    }
  }
  emit(name, ...args) {
    // 复制一份。防止回调里继续on，导致死循环
    const tasks = this.cache[name].slice();
    if (tasks) {
      for (let fn of tasks) {
        fn(...args);
      }
    }
  }
  once(name, cb) {
    function fn(...args) {
      cb(args);
      this.off(name, fn);
    }
    this.on(name, fn);
  }
}

const eventBus = new EventEmitter();
// 组件一
eventBus.on("event", (val) => {
  console.log(val);
});
// 组件二
eventBus.emit("event", "params");
```

## 0303

- :+1:好文推荐，[cjs 跟 esm 互相转换](https://juejin.cn/post/7205897684624474168)

- [fix unknown rule @tailwindcss ](https://flaviocopes.com/fix-unknown-at-rule-tailwind/)

## 0304

- [tailwindcss 入坑中，需要逐渐熟悉以及学会基本配置](https://www.tailwindcss.cn/docs)

## 0305

- tailwindcss 中如何进行主题模式切换[手动切换深色模式](https://www.tailwindcss.cn/docs/dark-mode)

```html
<!-- Dark mode enabled -->
<html class="dark">
  <body>
    <!-- Will be black -->
    <div class="bg-white dark:bg-black">
      <!-- ... -->
    </div>
    <script>
      // On page load or when changing themes, best to add inline in `head` to avoid FOUC
      if (
        localStorage.theme === "dark" ||
        (!("theme" in localStorage) &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("dark");
      } else {
        document.documentElement.classList.remove("dark");
      }
      // Whenever the user explicitly chooses light mode
      localStorage.theme = "light";
      // Whenever the user explicitly chooses dark mode
      localStorage.theme = "dark";

      // Whenever the user explicitly chooses to respect the OS preference
      localStorage.removeItem("theme");
    </script>
  </body>
</html>
```
