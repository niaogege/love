# 202303

金三银四，三月是人员变动比较频繁的一个月！:broken_heart:

## 0301

::: danger

算法能不能进一步点?? 灵魂拷问？？
:::

- vitepress 头部 head 设置,阔以设置 icon 和 meta

```js
  head: [
    ['link', { rel: 'icon', type: 'image/svg+xml', href: '/logo.svg' }],
    ['link', { rel: 'icon', type: 'image/png', href: '/logo.png' }],
    [
      'meta',
      { name: 'wwads-cn-verify', content: '5878a7ab84fb43402106c575658472fa' },
    ],
    ],
  ],
```

- Web Components 概念

Web Components 是一组标准化的**浏览器 API**，它们可以帮助我们创建可重用的组件。使用 Web Components，我们可以将一个组件封装在一个自定义元素中，并且可以在多个项目中重复使用这个组件。

Web Components 主要包括四个 API：**Custom Elements**、Shadow DOM、HTML Templates 和 HTML Imports。其中

- Custom Elements 允许我们创建自定义元素，
- Shadow DOM 允许我们创建封装的 DOM 节点，
- HTML Templates 允许我们创建可重复使用的模板，
- HTML Imports 允许我们导入 HTML 文件并在页面中使用它们。

## 0302

### 前端设计模式之工厂模式

工厂模式通俗点说就是：更方便地去创建实例

```js
class Axios {}
class Factory {
  create() {
    return new Axios();
  }
}
const axios = new Factory();
export default axios;
// 创建实例
const httpRequest1 = axios.create();
const httpRequest2 = axios.create();
const httpRequest3 = axios.create();
```

### 单例模式

定义一个类，生成一个实例，并且整个项目仅此这一个实例，封装一个请求的 Axios 实例然后暴露出去

```js
// utils/request.js
// 定义一个类
class HttpRequest {
  instance: AxiosInstance;
  constructor(options: CreateAxiosOptions) {
    this.instance = axios.create(options)
  }
  setHeader() {...}
  get() {...}
  post() {...}
  put() {...}
  delete() {...}
}
// 生成一个实例
const request = new HttpRequest({})

// 全局仅用这么一个请求实例
export default request
```

然后在项目中各处去使用这一个请求实例

```js
import request '@/utils/request'

const fetchData = (url) => {
  return request.get(url)
}
```

### 适配器模式

核心： 将一种格式适配成你所需要的格式

比如有一个场景：后端给你返回了三种数据格式，但是你需要把这三种格式转成你前端所需要的格式

```js
// 格式1
const data1 = [{ age1: 20, name1: "林三心" }];
// 格式2
const data2 = [{ age2: 20, name2: "林三心" }];
```

这个时候你需要定义几个适配器类

```js
class Adapter1 {
  data: { age1: number, name1: string }[];
  constructor(data) {
    this.data = data;
  }
  transform() {
    return this.data.map(({ age1, name1 }) => ({
      age: age1,
      name: name1,
    }));
  }
}

class Adapter2 {
  // 同理
}
```

当你需要转换成你需要的数据时，调用这些类就行

```js
const adapter1 = new Adapter1(data1);
// 适配成功
const data = adapter1.transform();
```

### 观察者模式

核心：定义对象间的**一种一对多的依赖关系**，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知

我们平时使用的框架 Vue，它的响应式就是基于观察者模式去做的，下面是简单展示一下它的原理

```ts
class Subject {
  count: number;
  observers: any[];
  constructor() {
    this.count = 0;
    this.observers = [];
  }
  getCount() {
    return this.count;
  }
  setCount(count: number) {
    // 设置值之后通知更新
    this.count = count;
    this.notify();
  }
  notify() {
    this.observers.forEach((o) => {
      o.update();
    });
  }
  push(o) {
    this.observers.push(o);
  }
}

class Observer {
  private name;
  private subject;
  constructor(name: string, sub: Subject) {
    this.name = name;
    this.subject = sub;
    this.subject.push(this);
  }
  update() {
    console.log(`${this.name} 变了 ${this.subject.getCount()}`);
  }
}
const sub = new Subject();
// 观察一号
const observer1 = new Observer("一号", sub);
// 观察二号
const observer2 = new Observer("二号", sub);

sub.setCount(1);
// 一号 变了 1
// 二号 变了 1
```

### 发布订阅模式

发布订阅模式跟观察者模式很像，他们其实都有发布者和订阅者，但是他们是有区别的
观察者模式的发布和订阅是互相依赖的
发布订阅模式的发布和订阅是不互相依赖的，因为有一个统一调度中心

Vue EventBus 就是用了发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.cache = {};
  }
  on(name, fn) {
    const tasks = this.cache[name];
    if (tasks) {
      this.cache[name].push(fn);
    } else {
      this.cache[name] = [fn];
    }
  }
  off(name, fn) {
    const tasks = this.cache[name];
    if (task) {
      const index = tasks.findIndex((item) => item === fn);
      if (index >= 0) {
        this.cache[name].splice(index, 1);
      }
    }
  }
  emit(name, ...args) {
    // 复制一份。防止回调里继续on，导致死循环
    const tasks = this.cache[name].slice();
    if (tasks) {
      for (let fn of tasks) {
        fn(...args);
      }
    }
  }
  once(name, cb) {
    function fn(...args) {
      cb(args);
      this.off(name, fn);
    }
    this.on(name, fn);
  }
}

const eventBus = new EventEmitter();
// 组件一
eventBus.on("event", (val) => {
  console.log(val);
});
// 组件二
eventBus.emit("event", "params");
```

## 0303

- :+1:好文推荐，[cjs 跟 esm 互相转换](https://juejin.cn/post/7205897684624474168)

- [fix unknown rule @tailwindcss ](https://flaviocopes.com/fix-unknown-at-rule-tailwind/)

## 0304

- [tailwindcss 入坑中，需要逐渐熟悉以及学会基本配置](https://www.tailwindcss.cn/docs)

## 0305

- tailwindcss 中如何进行主题模式切换[手动切换深色模式](https://www.tailwindcss.cn/docs/dark-mode)

```html
<!-- Dark mode enabled -->
<html class="dark">
  <body>
    <!-- Will be black -->
    <div class="bg-white dark:bg-black">
      <!-- ... -->
    </div>
    <script>
      // On page load or when changing themes, best to add inline in `head` to avoid FOUC
      if (
        localStorage.theme === "dark" ||
        (!("theme" in localStorage) &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("dark");
      } else {
        document.documentElement.classList.remove("dark");
      }
      // Whenever the user explicitly chooses light mode
      localStorage.theme = "light";
      // Whenever the user explicitly chooses dark mode
      localStorage.theme = "dark";

      // Whenever the user explicitly chooses to respect the OS preference
      localStorage.removeItem("theme");
    </script>
  </body>
</html>
```

## 0306

- 今天老铁问我要不要去他们那边，那边留有一个高级的 HC,我还是没有准备好，那到底啥时候准备好？明明知道自己的劣势和缺点，为啥就不能在努力准备准备呢？

> 问问自己，是否真的已经足够努力了？是否对得起自己对前端的这份热爱？

### 函数柯里化

[一个多参数的函数转换成多个嵌套的单参数函数](https://mp.weixin.qq.com/s/8FmjffUnWx49LsyJn28XdA)

```js
function add(a, b, c, d) {
  return a + b + c + d;
}
// expected
curry(add)(1)(2)(3)(4);

function curry(target) {
  return function fn(...rest) {
    if (target.length === rest.length) {
      return target.apply(null, rest);
    } else {
      // return fn.bind(null, ...rest)
      return (...arg) => fn(...arg, ...rest);
    }
  };
}
// 参数不固定
function curry2(target) {
  var arr = [];
  return function fn(...arg) {
    if (arg.length) {
      arr.push(...arg);
      return fn;
    } else {
      var value = target.apply(null, arr);
      arr = [];
      return value;
    }
  };
}
const add2 = (...rest) => {
  return rest.reduce((acc, cur) => cur + acc, 0);
};
curry2(add2)(1)(2)(3)();
```

## 0307

- 多重循环中嵌套异步函数最佳实践？

### 猜猜打印顺序,[async/await 原文地址](https://mp.weixin.qq.com/s/XzsK_rTwAffgbOyYlbSqGQ)

```js
async function jackson() {
  console.log(await Promise.resolve("jackson"));
}
async function bear() {
  console.log(await "bear");
}
async function daxiong() {
  console.log("daxiong");
}
jackson();
bear();
daxiong();
// daxiong  jackson bear
```

看看下列打印顺序

```js
async function async1() {
  await new Promise((resolve, reject) => {
    resolve();
  });
  console.log("A");
}
async1();
new Promise((resolve) => {
  console.log("B");
  resolve();
})
  .then(() => {
    console.log("C");
  })
  .then(() => {
    console.log("D");
  });
// B A C D
```

```js
async function async1() {
  await async2();
  console.log("A");
}
async function async2() {
  return new Promise((resolve, reject) => {
    resolve();
  });
}
async1();
new Promise((resolve) => {
  console.log("B");
  resolve();
})
  .then(() => {
    console.log("C");
  })
  .then(() => {
    console.log("D");
  })
  .then(() => {
    console.log("E");
  });
// B C D A E
```

async 根据返回值的类型，引起 js 引擎 对返回值处理方式的不同

async 函数在抛出返回值时，会根据返回值类型开启不同数目的微任务

- return 结果值：非 thenable、非 promise（不等待）
- return 结果值：thenable（等待 1 个 then 的时间）
- return 结果值：promise（等待 2 个 then 的时间）

- 非 thenable、非 promise（不等待）

```js
async function testA() {
  return 111;
}

// async function testA1() {
//   return Promise.resolve("2222");
// }

testA1().then((a) => console.log(1, a));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
// 1 111
// 2
// 3
```

- thenable（等待 1 个 then 的时间）

```js
async function testB() {
  return {
    then(cb) {
      cb();
    },
  };
}

testB().then(() => console.log(1));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));

// (等待一个then)最终结果👉: 2 1 3
```

- promise 等待 2 个 then

```js
async function testC() {
  return new Promise((resolve, reject) => {
    resolve();
  });
}

testC().then(() => console.log(1));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));

// (等待两个then)最终结果👉: 2 3 1

async function testC() {
  return new Promise((resolve, reject) => {
    resolve();
  });
}

testC().then(() => console.log(1));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3))
  .then(() => console.log(4));

// (等待两个then)最终结果👉: 2 3 1 4
```

经典面试题

```js
async function async1() {
  console.log("1");
  await async2();
  console.log("AAA");
}

async function async2() {
  console.log("3");
  return new Promise((resolve, reject) => {
    resolve();
    console.log("4");
  });
}

console.log("5");

setTimeout(() => {
  console.log("6");
}, 0);

async1();

new Promise((resolve) => {
  console.log("7");
  resolve();
})
  .then(() => {
    console.log("8");
  })
  .then(() => {
    console.log("9");
  })
  .then(() => {
    console.log("10");
  });
console.log("11");

// 5 1 3 7 11 8 9 4 aaa 10 6
// 5 1 3 4 7 11 8 9 aaa 10 6
```

步骤拆解：

- 先执行同步代码，输出 5
- 执行 setTimeout，是放入宏任务异步队列中
- 接着执行 async1 函数，输出 1
- 执行 async2 函数，输出 3
- Promise 构造器中代码属于同步代码，输出 4
  > async2 函数的返回值是 Promise，等待 2 个 then 后放行，所以 AAA 暂时无法输出
- async1 函数暂时结束，继续往下走，输出 7
- 同步代码，输出 11
- 执行第一个 then，输出 8
- 执行第二个 then，输出 9
- 终于等到了两个 then 执行完毕，执行 async1 函数里面剩下的，输出 AAA
- 再执行最后一个微任务 then，输出 10
- 执行最后的宏任务 setTimeout，输出 6

### await 右值类型区别

#### 非 thenable

```js
async function test() {
  console.log(1);
  await 1;
  console.log(2);
}
test();
console.log(3);
// 最终结果👉: 1 3 2
```

```js
function func() {
  console.log(2);
}
async function test() {
  console.log(1);
  await func();
  console.log(3);
}
test();
console.log(4);
// 1 2 4 3

async function test() {
  console.log(1);
  await 123;
  console.log(2);
}

test();
console.log(3);

Promise.resolve()
  .then(() => console.log(4))
  .then(() => console.log(5))
  .then(() => console.log(6))
  .then(() => console.log(7));
// 1 3 2   4567
```

总结： await 后面接非 **thenable** 类型，会立即向微任务队列添加一个微任务 then，但不需等待

#### thenable 类型

```js
async function test() {
  console.log(1);
  await {
    then(cb) {
      cb();
    },
  };
  console.log(2);
}
test();
console.log(3);

Promise.resolve()
  .then(() => console.log(4))
  .then(() => console.log(5))
  .then(() => console.log(6))
  .then(() => console.log(7));
// 1 3 4 2 5 6 7
```

总结： await 后面接 thenable 类型，需要等待一个 then 的时间之后执行

#### Promise 类型

```js
async function test() {
  console.log(1);
  await new Promise((resolve, reject) => {
    resolve();
  });
  console.log(2);
}

test();
console.log(3);
Promise.resolve()
  .then(() => console.log(4))
  .then(() => console.log(5))
  .then(() => console.log(6))
  .then(() => console.log(7));
// 1 32  4 5 6 7
```

❓ 为什么表现的和非 thenable 值一样呢？为什么不等待两个 then 的时间呢？

```js
async function func() {
  console.log(1);
  await 1;
  console.log(2);
  await 2;
  console.log(3);
  await 3;
  console.log(4);
}

async function test() {
  console.log(5);
  await func();
  console.log(6);
}

test();
console.log(7);

Promise.resolve()
  .then(() => console.log(8))
  .then(() => console.log(9))
  .then(() => console.log(10))
  .then(() => console.log(11));

// 5 1 7 2 8 3 9 4 10 6 11

async function test() {
  console.log(5);
  console.log(1);
  Promise.resolve()
    .then(() => console.log(2))
    .then(() => console.log(3))
    .then(() => console.log(4))
    .then(() => console.log(6));
}

test();
console.log(7);

Promise.resolve()
  .then(() => console.log(8))
  .then(() => console.log(9))
  .then(() => console.log(10))
  .then(() => console.log(11));

// 最终结果👉: 5 1 7 2 8 3 9 4 10 6 11
```

走一个案例

```js
async function func() {
  console.log(2);
  return {
    then(cb) {
      cb();
    },
  };
}
async function test() {
  console.log(1);
  await func();
  console.log(3);
}
test();
console.log(4);
new Promise((resolve) => {
  console.log("B");
  resolve();
})
  .then(() => {
    console.log("C");
  })
  .then(() => {
    console.log("D");
  });
// 1 2 4 b c 3 d
```

#### async/await 总结

- async 函数返回值
  结论：async 函数在抛出返回值时，会根据返回值类型开启不同数目的微任务
  1.return 结果值：非 thenable、非 promise（不等待）
  2.return 结果值：thenable（等待 1 个 then 的时间）
  3.return 结果值：promise（等待 2 个 then 的时间）
- await 右值类型区别:

  1.接非 thenable 类型，会立即向微任务队列添加一个微任务 then，但不需等待

  2.接 thenable 类型，需要等待一个 then 的时间之后执行

  3.接 Promise 类型(有确定的返回值)，会立即向微任务队列添加一个微任务 then，但不需等待

### 图片裁剪？ctx.drawImage()

原图像从坐标 (33,71) 处截取一个宽度为 104 高度为 124 的图像。并将其绘制到画布的 (21, 20) 坐标处，并将其缩放为宽 87、高 104 的图像。

```js
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const image = document.getElementById("source");

image.addEventListener("load", (e) => {
  ctx.drawImage(image, 33, 71, 104, 124, 21, 20, 87, 104);
});
```

- 更新了下自己的简历，真想加这两句话？hhhh,我真的太自恋了，希望假以时日吧

```md
- 精通 react
- 精通 ssr
```

> 实力配不上我的野心？？？how to do?

什么时候我才能像三元大佬，岀一版自己的小册子[基于 Vite 的 SSG 框架开发实战](https://juejin.cn/video/7163857336258265102?scrollMenuIndex=0)

## 0308

- :100: [前端构建工具进化历程](https://mp.weixin.qq.com/s/o8B8HAczZtIZM8V_HHwNqg)

> 字节出品 感觉就不一样，还是太厉害了，膜拜膜拜

什么是构建？简单来说：构建就是将开发环境的代码转化成生产环境可用来部署的代码。为了生产出生产环境可用的 JS、CSS，构建工具实现了诸如：**代码转换、代码压缩、tree shaking、code spliting** 等。

## 0309

- [vue2 和 vue3 响应式区别](https://mp.weixin.qq.com/s/FGTy5oUAzpCQizZJKJNoMw)

  > 手写 Observer/watcher

- [react 灵魂拷问 23 个](https://mp.weixin.qq.com/s/yPJ4mwTxm-WEFAv2h4SL8Q)
  > 我感觉自己回答 5 个,看到了才能回想起来，总结来说还是没有掌握

## 0310

- 个人主题首页还没有整完，这速度也太慢了！！！自己开发效率太慢了

## 0311

- 去了一趟常州，累个半死，:mask:,来回车票花销 300
- 结婚前的婚纱照拍摄需要提上日程，最迟这周五确定，还要确定的是婚庆相关的事宜
- 确定提亲的日子，提什么亲？

## 0312

- 结婚事宜女方这边难以推进，艰难
- 手写各种排序

```js
// bubble sort
```

## 0313

- 突发奇想：如果从银行里借 10 万用于提前还房贷，这个每个月能少 500 的利息，银行十万一个月 400 的利息，这样每个月还你少还 100 左右的利息

### [react 每日小记](https://zhuanlan.zhihu.com/p/608959809)

jsx 会被编译成 render function，也就是类似 React.createElement 这种。所以之前写 React 组件都必须有一行 **import \* as React from 'react'**，因为编译后会用到 React 的 api。但后来改为了这种 render function：

```js
const Test = <div>THis is Test</div>;
```

由 babel、tsc 等编译工具自动引入一个 **react/jsx-runtime** 的包.
vdom 转 fiber 的流程叫做 reconcile，我们常说的 diff 算法就是在 reconcile 这个过程中.经过 reconcile 之后，就有了新的 fiber 树了.

react 渲染流程整体分为两个大阶段： render 阶段和 commit 阶段。

- render 阶段也就是 **reconcile 的 vdom 转 fiber 的过程**

- commit 阶段就是具体操作 dom，以及执行副作用函数的过程。commit 阶段还分为了 3 个小阶段：before mutation、mutation、layout。

## 0314

- 今天开始接触 [nextjs 中文](https://www.nextjs.cn/docs/basic-features/pages),[nextjs en](https://nextjs.org/docs/basic-features/pages)从下周开始忙开发，会一直忙到下个月,希望能有新的收获!!!

### 面试官问什么是 event loop?

答：eventLoop 是 js 运行时的一个重要机制，解决 js 单线程运行时不会阻塞的一种机制，负责协调和管理 js 程序中各种任务的执行。eventloop 原理是通过将任务分配到不同的队列中，并按照一定的规则来管理任务的执行顺序。在 js 中，有一个主线程负责执行任务，同时还有一个或者多个微任务和宏任务队列，微任务队列中的优先级比较高，优于宏任务执行，而同一队列中的任务是按照添加的先后顺序执行。

1.Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。
2.JS 调用栈采用的是**后进先出**的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。
3.Javascript 单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。

大白话大致是这样的:

- 所有同步任务都在主线程上执行，形成一个执行栈 (Execution Context Stack)。
- 而异步任务会被放置到 Task Table，也就是上图中的异步处理模块，当异步任务有了运行结果，就将该函数移入任务队列。
- 一旦执行栈中的所有同步任务执行完毕，引擎就会读取任务队列，然后将任务队列中的第一个任务压入执行栈中运行。

主线程不断重复第三步，也就是 **只要主线程空了，就会去读取任务队列，该过程不断重复，这就是所谓的** 事件循环。

### [Nodejs 中的 eventLoop?](https://juejin.cn/post/6844904194185379854#comment)

Node 的 Event loop 一共分为 6 个阶段，每个细节具体如下：

- timers: 执行 setTimeout 和 setInterval 中到期的 callback。
- pending callback: 上一轮循环中少数的 callback 会放在这一阶段执行,nodejs 内部在使用
- idle/prepare: 仅在内部使用。
- poll: 最重要的阶段，执行 pending callback，在适当的情况下会阻塞在这个阶段。
- check: 执行 setImmediate(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行 setImmediate 指定的回调函数)的 callback。
- close callbacks: 执行 close 事件的 callback，例如 **socket.on('close'[,fn]) or http.server.on('close, fn)**。

### 大循环和小循环

大循环指的就是 event loop，小循环就是指由 next tick callback queue 和 microtask callback queue 所组成的小循环。我们可以下这么一个结论：一旦进入大循环之后，每执行完一个大循环 callback 之后，就必须检查小循环。如果小循环有 callback 要执行，则需要执行完所有的小循环 calback 之后才会回归到大循环里面。 注意，这里强调的是，nodejs 不会把 event loop 中当前阶段的队列都清空之后才进入小循环，而是执行了一个 callback 之后，就进入了小循环了

### nodejs 与 browser 中 event loop 的区别

- 相同点
  从运行机制的实质上来看，两者大体上是没有什么区别的。具体展开来说就是：如果把 nodejs event loop 中的 mainline code 和各个阶段中的 callback 都归纳为 macrotask callback，把 next tick callback 和其他诸如 Promise/then()的 microtask callback 都归纳为 microtask callback 的话，这两个 event loop 机制大体是一致的：都是先执行一个 macrotask callback，再执行一个完整的 microtask callback 队列。microtask callback 都具备递归入队的特性，无限递归入队都会产生“event loop starvation”后果。只有执行完 microtask callback queue 中的所有 callback，才会执行下一个 macrotask callback。

- 异同点

  1.在 nodejs event loop 的实现中，没有 macrotask 的说法。
  nodejs event loop 是按照阶段来划分的，具有六个阶段，对应六种类型的队列（其中两种是只供内部使用）；而 browser event loop 不按照阶段划分，只有两种类型的队列，即 macrotask queue 和 microtask queue。从另外一个角度我们可以这么理解：nodejs event loop 有 2 个 microtask 队列，有 4 个 macrotask 队列；而浏览器 event loop 只有 1 个 microtask 队列，有 1 个 macrotask 队列。

  2.最大的不同，在于 nodejs evnet loop 有个轮询阶段。当 evnet loop 中所有队列都为空的时候，browser event loop 会退出 event loop（或者说处于休眠状态）。但是 nodejs event loop 不一样，它会持续**命中轮询阶段**，并且在那里等待处于**pending 状态的 I/O callback**。只有等待时间超出了 nodejs 计算出来的限定时间或者再也没有未完成的 I/O 任务的时候，nodejs 才会退出 event loop。这就是 nodejs event loop 跟 browser event loop 最大不同的地方。

## 0315

- 如何修改 create-react-app 打包输出的文件路径/名称(appBuild)
  在 React 项目跟目录下（跟 src 同级）添加 **.env.production** 文件

```js
// 例如我需要将默认的 build 修改为 dist
BUILD_PATH = dist;
```

- pm2 维护 nextjs 项目，在公司平台上发布，健康检查没有通过，还是不太懂这块发布流程，需要学习下！！！

## 0316

- 跨域，今天测试同学说以为只要主域是 bytheway.com 的都不涉及跨域，其实不是的
  在请求时，如果出现了以下情况中的任意一种，那么它就是跨域请求：
- 协议不同，如 http 和 https；
- 域名不同，即使主域相同，子域不同也是跨域的
- 端口不同。

cors 策略时，设置“**Access-Control-Allow-Origin**”参数即可解决跨域问题，此参数就是用来表示允许跨域访问的原始域名的，当设置为“\*”时，表示允许所有站点跨域访问

- vite 项目打完包之后，执行**vite preview**是怎样做到预览的?
