import{_ as i,c as a,a2 as l,o as n}from"./chunks/framework.pOih8ab_.js";const d=JSON.parse('{"title":"202410","description":"","frontmatter":{},"headers":[],"relativePath":"work/2024/202410.md","filePath":"work/2024/202410.md"}'),t={name:"work/2024/202410.md"};function h(e,s,k,p,r,E){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="_202410" tabindex="-1">202410 <a class="header-anchor" href="#_202410" aria-label="Permalink to &quot;202410&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">INFO</p><blockquote><p>2024010 国庆放假回来，不知道前端知识忘记了多少</p></blockquote></div><h2 id="_1008" tabindex="-1">1008 <a class="header-anchor" href="#_1008" aria-label="Permalink to &quot;1008&quot;">​</a></h2><ul><li>1216</li><li>如何度过这漫长而又苦逼的一生？微笑面对，smile to life</li><li><a href="https://mp.weixin.qq.com/s/EKTAYspvloDXiKwaBnwazA" target="_blank" rel="noreferrer">Http 请求中增加的新的方法类型</a>,总结起来就是： 1.能承载大量请求数据 2.保证请求的幂等性和安全性。QUERY 是一种安全且幂等的 HTTP 请求方法，它允许携带请求内容。与 GET 方法不同，QUERY 方法并不请求服务器返回指定 URI 资源的表示，而是要求服务器根据请求内容进行查询操作。简单来说，QUERY 方法通过请求体来定义查询操作，并将操作结果作为响应返回。</li><li><a href="https://mp.weixin.qq.com/s/HxS-g3ldqhs-y1YE7uWnJA" target="_blank" rel="noreferrer">数组解构是如何降低 JavaScript 的运行速度</a></li><li>prisma 中的事务是什么？有啥用？</li><li>想法：现实中买房或者租房成本太高，如果一旦不合适，就要承担高额违约金，就不能推出试用版，试用一周或者两周，都是付费，如果不合适解约就行，也不需要支付这么贵的金额</li><li>现在企业招聘都要求：有 Node.js 或者 AI 项目开发经验者优先？<a href="https://github.com/ruanyf/weekly/issues/5090" target="_blank" rel="noreferrer">招聘目录</a></li></ul><h2 id="_1009" tabindex="-1">1009 <a class="header-anchor" href="#_1009" aria-label="Permalink to &quot;1009&quot;">​</a></h2><ul><li>1217</li><li>最难熬的一季，老婆还有最后三个月就要生了，需要额外关照，每年冬天也是公司裁员的高峰期，还要面临被裁员的风险，buffer 叠满，双重压力。感觉压力快赶上上海最黑暗的时刻了。每次产检都紧张的要死要死，希望宝宝一切都好</li><li><a href="https://www.ruanyifeng.com/blog/2024/07/copilot-vs-marscode.html" target="_blank" rel="noreferrer">大佬的博客干活满满，值得一读</a></li><li>“每个人的生活都是一条通向自身的道路。每个人的真正职责只有一个：找到自我。然后在心中坚守一生，全心全意，永不停息。 所有其它的路都是不完整的，是人的逃避方式，是对社会角色的懦弱伪装，是随波逐流，是对内心的恐惧。”</li><li>最近  ECMAScript  引入了一个新的提案：proposal-safe-assignment-operator，中文翻译为：安全赋值运算符，代码中是<code>?=</code></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] ?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> api.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>很多人会问，为啥要将  error  放前面，而  result  放后面呢？其实很好理解，因为并不是所有函数执行都会有返回结果的，换句话说：error 是客观存在的，result 是主观存在的，所以  error  放前面更方便，代码判断起来更加舒服</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> resolvePromise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] ?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> resolvePromise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error, res)</span></span></code></pre></div><h2 id="_1010" tabindex="-1">1010 <a class="header-anchor" href="#_1010" aria-label="Permalink to &quot;1010&quot;">​</a></h2><ul><li>1217</li><li>MemoryRouter 与 BrowserRouter 的区别是什么？</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>MemoryRouter 和 BrowserRouter 是 react-router-dom 库中提供的两种不同类型的路由组件，它们在数据持久性和使用场景上有所不同： 1.数据持久性：</p><p>BrowserRouter：使用浏览器的历史 API 来管理路由状态，这意味着路由状态会被持久化到浏览器的历史记录中。当你使用 BrowserRouter 时，用户可以通过浏览器的前进和后退按钮来导航到不同的路由状态。 MemoryRouter：路由状态仅存在于内存中，不依赖于浏览器的历史记录。这意味着，当用户刷新页面或者关闭并重新打开浏览器时，MemoryRouter 将不会记住之前的路由状态。</p><p>2.使用场景：<br> BrowserRouter：适用于大多数 SPA（单页应用程序）场景，因为它与浏览器的历史记录集成，提供了自然的导航体验。 MemoryRouter：适用于不需要持久化路由状态的场景，如： 服务器端渲染（SSR）的应用程序，因为服务器端渲染时没有浏览器环境，所以不能使用 BrowserRouter。 模态对话框或弹出窗口内部的路由，这些组件可能需要自己的路由逻辑，而不干扰主应用程序的路由状态。 测试环境，用于模拟路由行为而不影响全局的路由状态。 临时的、一次性的路由需求，例如，当你需要一个独立的路由实例来展示某个组件，而不希望这个状态被持久化。</p></div><ul><li>ios 白屏率优化？h5 页面能做啥，该做的缓存和压缩/http2.0/已经有了，还能做啥？</li></ul>`,13)]))}const g=i(t,[["render",h]]);export{d as __pageData,g as default};
